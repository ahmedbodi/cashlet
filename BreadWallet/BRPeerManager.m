//
//  BRPeerManager.m
//  BreadWallet
//
//  Created by Aaron Voisine on 10/6/13.
//  Copyright (c) 2013 Aaron Voisine <voisine@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

#import "BRPeerManager.h"
#import "BRPeer.h"
#import "BRPeerEntity.h"
#import "BRBloomFilter.h"
#import "BRKeySequence.h"
#import "BRTransaction.h"
#import "BRTransactionEntity.h"
#import "BRMerkleBlock.h"
#import "BRMerkleBlockEntity.h"
#import "BRWalletManager.h"
#import "NSString+Bitcoin.h"
#import "NSData+Bitcoin.h"
#import "NSManagedObject+Sugar.h"
#import "BREventManager.h"
#import "breadwallet-Swift.h"
#import <netdb.h>

#if ! PEER_LOGGING
#define NSLog(...)
#endif

#define FIXED_PEERS          @"FixedPeers"
#define PROTOCOL_TIMEOUT     20.0
#define MAX_CONNECT_FAILURES 20 // notify user of network problems after this many connect failures in a row
#define CHECKPOINT_COUNT     (sizeof(checkpoint_array)/sizeof(*checkpoint_array))
#define GENESIS_BLOCK_HASH   (*(UInt256 *)@(checkpoint_array[0].hash).hexToData.reverse.bytes)
#define SYNC_STARTHEIGHT_KEY @"SYNC_STARTHEIGHT"

#if BITCOIN_TESTNET

static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
};

static const char *dns_seeds[] = {
};

#else // main net

// blockchain checkpoints - these are also used as starting points for partial chain downloads, so they need to be at
// difficulty transition boundaries in order to verify the block difficulty at the immediately following transition
static const struct { uint32_t height; const char *hash; uint32_t timestamp; uint32_t target; } checkpoint_array[] = {
    { 0, "4d96a915f49d40b1e5c2844d1ee2dccb90013a990ccea12c492d22110489f0c4", 1389311371, 0x01000000u },
    { 2016, "81d969f8f0bd5543ce5f506fb2b12be14a8b9f3fea35d88771ce621adbba1125", 1389435044, 0x01000000u },
    { 4032, "985c4aa52b56f8dc349089d1141c0baac24b22aec871d44282b8114c8a0ee989", 1389438911, 0x01000000u },
    { 6048, "27e9d16bef0ff7b3addc8c25783aeac9bfc99bf10185a78068bf0eb1dcf5d016", 1389445094, 0x01000000u },
    { 8064, "21156fe43c92249485f234c05b9c654398c57e1e7da2616b790ee275a9e79daa", 1389457522, 0x01000000u },
    { 10080, "30a29c5665cad3f9e700d3f551ce51d9014e586710255df47afdb6caa0c34405", 1389494639, 0x01000000u },
    { 12096, "591ddffbc198a456d5ec4bacba7fc96a248785bc0ba8bf9b95865b47f1b018ca", 1389547587, 0x01000000u },
    { 14112, "988dc8270fc35e6d85e73d55e349508e575765d14686ee836c9b6ad71da86693", 1389676213, 0x01010000u },
    { 16128, "f708aeb9d32d1cfb99716acbc786d53783a8b4d1402b7291140421d9b0650b02", 1389869038, 0x01020000u },
    { 18144, "8a5ea59616bbd22e982e6e4a4fc53b957d8ca657a6d7a453f79a6df7831eaaa3", 1390194345, 0x01020000u },
    { 20160, "3da5330dc1abcce95f918663476e94c9643a3936661cb039a7f585054659bb14", 1390306772, 0x01050000u },
    { 22176, "8305d2436c79eaf32dbeb5ff7023eabd8cb81bfcdeb1c48ba671cd2ff208edc9", 1390521416, 0x01070000u },
    { 24192, "69622465ae61faae7919b462c25219930abab18704e87fea891e895d1f7e9bc6", 1390700454, 0x010d0000u },
    { 26208, "0f0b611647a913b0b480e0775ce4239b3834f8395f5572301dd35cdfe7da4344", 1391111035, 0x01090000u },
    { 28224, "d9ad56894ea985ebf559141a4d533d086ce15c4c7f1c7a6dd42e0f1d10385697", 1391390274, 0x010f0000u },
    { 30240, "457ced27cb2fe61235ea8821a02d0984e2f78d5b051ba43e934f4c3c5a07db79", 1391640580, 0x02009000u },
    { 32256, "2b22783e6eb5b02fdc2669931c60156be4eb1f1d9a8ffed4a69a5f8aa50f9131", 1391955918, 0x017b0000u },
    { 34272, "ba3e32e8cc11ccd7af3be92d5d3f04883f09fc919deb25196035b47c09c615ca", 1392252795, 0x02008300u },
    { 36288, "1dcbbcd6f7e30b588e0ef5a80642eded10b65feebca5e1006658285b72bbf441", 1392569747, 0x015a0000u },
    { 38304, "e4d8848fc80d1988d64a0bb6206b1251bf34278583abc872e7f76316f8ce767b", 1392867104, 0x016f0000u },
    { 40320, "cf361ecd18812f7b2da3c54cad4f9ab17afb8d2f744405104e9f2f773abd0662", 1393161170, 0x02008900u },
    { 42336, "48d4f60eca28e3205c45ee71f92436b2e0d4f98e122fad04e93c9a36b7c990fc", 1393467985, 0x02008000u },
    { 44352, "44e5b428f5c496dbb196878d20ea10cc2b8082507934f91ab8a27426e067f221", 1393755544, 0x02009600u },
    { 46368, "26defffea3f80361cba25080cf18514d70ab3d4d89ea7717d11660304566be1f", 1394049876, 0x0200a600u },
    { 48384, "8442a9f8b120d9a1769beac12c6d1934797c5c4e55754e55658daaa550338c69", 1394361885, 0x02008d00u },
    { 50400, "efbe50971fbd5f28d9b253dbdaf9c4202fa549d524d7da96f35b7bc86c3586f2", 1394654816, 0x0200a100u },
    { 52416, "e2cc3907563bea6a9d6ac8e0411307e4439fe3ed7a1fee113d107e3891f4b1e6", 1394973840, 0x01710000u },
    { 54432, "04da82fe66562b33f821f61af7d103d62f27d91752e3a68f19388ec4662641a1", 1395275340, 0x02009600u },
    { 56448, "6e7756953eff6995e17c96ab0c3ad048fe96b5e7b7960eff9c4aea26e61af73a", 1395553895, 0x02012800u },
    { 58464, "3da5ff1ad2495a097ff808097619206c2975c28d08cea91f4d5a13255812960d", 1395864743, 0x0200f400u },
    { 60480, "fa5c0e602ac02af723d06a8d629a14204ac2b49b1ad38f91ee43189d235ba52e", 1396166071, 0x0200ec00u },
    { 62496, "87584e5db631e0ffe7e5ec984b3776ae44eecc671299f4b43ebdb566c30c21ab", 1396469802, 0x0200f000u },
    { 64512, "3a317bb680da35ac550b422a8de60477452564bda05a06d6c7c8402d417d0e63", 1396785284, 0x0200d000u },
    { 66528, "1ea8f3bba9327d5549fc9080c2a20614b52598cd5ca8a8ae338e2b051d83a327", 1397076653, 0x0200ed00u },
    { 68544, "60169cada6598d1500f892b39dc08ebfbe3eabcec40db762e9b9ea435af607fd", 1397380222, 0x02010200u },
    { 70560, "55eeb43b0945bae4cd219326cc57a206e63ffb3a7e54f40b3b20afef18e378b2", 1397691860, 0x0200ea00u },
    { 72576, "5f4e8540b97ca7407bf1f5ebaa03852f2c74347a16f896575ec5c52f38eb2e76", 1398013158, 0x0200ab00u },
    { 74592, "d57803078fb991861b6df20afd3dc81d7293e81330f753a28426a4ebcdc01303", 1398308783, 0x0200b700u },
    { 76608, "943c2f936f5735d80b3d1dd4a3d699530c1a12f9ad3a3d5e586d2c23a8139b9e", 1398602179, 0x0200c700u },
    { 78624, "5aed0a1ee1b1f60a97a649bf403b6a66db5356362b4ec7c92fdca59124735b43", 1398901974, 0x0200df00u },
    { 80640, "71a141ecdc6630caea7d86a7af950e45d28bc07dad264c24cd8c837ff020dbf2", 1399199635, 0x0200f200u },
    { 82656, "2307b755ccdd2062a20244161cde40e925894948907c13444d657cc6657fd89c", 1399503039, 0x0200f100u },
    { 84672, "2f21d2ed036c4fb38cc78ee47d177327b8f2bf97a48f9f2e89058e54a8d346ae", 1399804754, 0x0200f100u },
    { 86688, "1c938ca02225f928492a179ae4abe5a7c32d817fa4993eebd177f2f03d6de9a3", 1400099587, 0x02010d00u },
    { 88704, "dc7d3db28ad8464959c8aba472786464985638a0334f4fa820630efdfed616ea", 1400395561, 0x02012f00u },
    { 90720, "c1be657a3a9265de7541e2425e4eabe3fd531a551b485bf2de961b4992307534", 1400696599, 0x02013500u },
    { 92736, "c9086a0df89b05f8b8dcb2ce9b4dddf5a1c5108296e2d19a9cd210445818b4eb", 1401006061, 0x02011e00u },
    { 94752, "6530ea5ee0ab1c85a44e3c9e86d94810c27190f48ba233772fa37cf7e3d75e17", 1401314120, 0x02011200u },
    { 96768, "2210dfd468f40e17d5b8d6db5189c2e3730bd95100f3317633e8a3222fb9b642", 1401623344, 0x0200fb00u },
    { 98784, "97aa6e3382ee88d527e7323666111cee5e35b6e05ec39cc6b6fe176e87d34add", 1401920795, 0x02010900u },
    { 100800, "38a18d738c94977364b57c3699a8b48e5f0c1fc94b87feabe3cc4eab0be3fa55", 1402232849, 0x0200f000u },
    { 102816, "22998e10650cc2af06dae5b01a1ed5af9deec4090fa34dd40db387fcbeac065d", 1402536045, 0x0200ec00u },
    { 104832, "0b20e6e0d01535d58b0c8f9f954021d62252684be02a0a7fc245f1a82ed77b0c", 1402838109, 0x0200ef00u },
    { 106848, "a16ce31e378c70bd2a6267612754859c01351c60c3b21b7ea8364d1a8c8a113a", 1403143893, 0x0200eb00u },
    { 108864, "b6e057835024dcc2b9c760e52cce6737a4e73ff5d60041fa9da0a50e5bc38c31", 1403449889, 0x0200e000u },
    { 110880, "9e422df6462d4e05498a1c65619bb59f8ab1a9dc9813d14f492f84b73d831e06", 1403753922, 0x0200d900u },
    { 112896, "58dc1140da4e5116069c31431ea545c1bd6512d44e449bcc85b01120624be8c9", 1404065162, 0x0200bb00u },
    { 114912, "857c50d792816b43cb7a76596178c25c51876dabaeff8f2b3d760385f987d3fd", 1404365119, 0x0200c300u },
    { 116928, "3b3f7d1dca2b83b445a776abff03ca00b714b5f81372cd3e5e8ef4aee2e1f3a6", 1404658126, 0x0200d900u },
    { 118944, "27891b4ee4f80acf43aef597d28db068e5234c87ddec2e3348649af1f83576a6", 1404971527, 0x0200be00u },
    { 120960, "9a24cd09d33f424369c620089c471ccdb850d609a7384eb096ced35b42ddd897", 1405280261, 0x0200aa00u },
    { 122976, "2fb80d337e6889c40ce229d5c0e97ea642cd4f1541a2bdf8df741375ec751d86", 1405592443, 0x02009800u },
    { 124992, "96469725a3c56539be66b779990d1bf7005877c861459468665eb2e7fc27e55f", 1405901577, 0x02008d00u },
    { 127008, "d8a1e57648195720608ada75be8226c2d952529a6d888cb680d3cd9c96f51081", 1406205826, 0x02008b00u },
    { 129024, "9d605735b174df5ec265047b881606fa8c4cba442854d97ba695c93cc3792c2b", 1406513493, 0x017d0000u },
    { 131040, "599b6a41b5a4b019b3a7be9580426fc1a80f432affae0cca34044923c8e78e60", 1406825077, 0x016b0000u },
    { 133056, "1522df1a45030a5070586c2dab040a16c2da2a0da496eea498c37593372f736d", 1407125398, 0x016c0000u },
    { 135072, "f023961c33969555019c9f253de4a3fe5d27e3888fd7ff7382e73b76f1e3d1e2", 1407417600, 0x01790000u },
    { 137088, "9037fb526037453b6b8adc8e70b9ffab154e65c6766749e8ae1a78723ca83572", 1407733774, 0x016a0000u },
    { 139104, "8be774f55eb1e68a441389be84e552f88fd4714b3ddf375c6f36c7d6e2670e95", 1408037244, 0x01680000u },
    { 141120, "f3f9cdc86128512a648009b1358fcdb010c4f3c178446dd1cacc0cc9ed8d797c", 1408345991, 0x015f0000u },
    { 143136, "89cc368c3735bfd4fbfa75d4ccc67324d1578b18004e98aa4b590e94ee625eca", 1408650025, 0x01560000u },
    { 145152, "0cef96aea9a5d3fb8a437b1b34b96bfc58f6b933065c5e2dfb9c93299ae845cd", 1408943246, 0x01670000u },
    { 147168, "6fce84329c928886f6c19cd57170c5d88bcd0d4d071a0d5fc3bfc62368b0cc45", 1409246324, 0x01670000u },
    { 149184, "a9dc61afc2b6a6528ad3c86993ee3a33498766e21d3163044e3e1ef83076b018", 1409557963, 0x01610000u },
    { 151200, "673ca6f05320941731a74e8b009f364569ceefca0b309b156d66f098feac40d1", 1409856968, 0x01620000u },
    { 153216, "714e6a1100e98ffc8797d9a82d6aab008ac1cf98b1010c1d4b31781ed548e37d", 1410167975, 0x015d0000u },
    { 155232, "a4dab70fa0635fa427f879446f11be46fc3fe2029641590682b14f64cd564704", 1410464360, 0x01600000u },
    { 157248, "35d6c1125583720aa0d6868fed53f61deb40e195c4056fffe5b3aa064972a28b", 1410771063, 0x015d0000u },
    { 159264, "6c839c22328da6f4ab786855783568eab821b1ede32c75067da6cec31ca26743", 1411076034, 0x015c0000u },
    { 161280, "6022777b1e30a4f2d75f3df308f4f7011bc481a34b98bc4a27a2790efa4d286a", 1411386690, 0x01540000u },
    { 163296, "fcb627c8f430a91305df744a577863b60a140ed13377ecbf85c02eb37b6e2ec5", 1411684535, 0x01570000u },
    { 165312, "d68d4e5ef75cdc831e06bf7c0f1f641045b44d73170742974736d023d27b44a6", 1411990184, 0x01560000u },
    { 167328, "071260361d230d3d43d8d776074294f6b74cbad9cf108fed6107b9db2291e1dd", 1412296940, 0x014f0000u },
    { 169344, "f750add3c8572e3939440c4816d2914cac67dacfe405c9268b7b86df8f4d6b31", 1412601311, 0x014f0000u },
    { 171360, "b261791fbb821f328a0b0ee3fdf48648650d0bd523f696eb9a9ac5ae2b9410d9", 1412914039, 0x01440000u },
    { 173376, "ceedd919c30409a9372bce09bc6a2c7bec58f524efc448b6247c0003162599ab", 1413215181, 0x01460000u },
    { 175392, "1d174d09bf4ecb5c0f3aeb39fa59034475008be20ff5728a79750f75d22c95fd", 1413518264, 0x01410000u },
    { 177408, "e5a4823ed253cf9e515936f0cfc6deb742c68a21ce0fa9c221a8d3765ca4683f", 1413821876, 0x01410000u },
    { 179424, "5fe7fe73b25f537dec47fa97c08e7b09d0616aff73c90defe339b0762463b06f", 1414124203, 0x01420000u },
    { 181440, "f148b1687a42b8ec07726431465943b12c5297df580067f559932c3eb47b025a", 1414426949, 0x01410000u },
    { 183456, "1a6098099e29dda85a70d85d1ab289039b19e7e84c9c6d4766d1c624da9e1469", 1414737775, 0x013c0000u },
    { 185472, "0ff913fe68babdb3b2dc97f664db4ec2304c7bf89f8ab4924156a2c921f20f2d", 1415043249, 0x013c0000u },
    { 187488, "e0888914409096bbaab435aaa4743d082cb51adc6d35250b0c0b20c85968a6db", 1415341837, 0x013d0000u },
    { 189504, "2d0ced12418080adfbfe0fe91046fd2803b16cac810d4ca21534f1ad7882418d", 1415644436, 0x013f0000u },
    { 191520, "1b4da0a8d20d5a8d2c62c8b1922a7ed7be26f43cf522540802284bbaa5290f28", 1415949681, 0x013e0000u },
    { 193536, "029322f83161979c5bba66e7ef4b7fa0e903719fd689dbf77c4efe75f37b4417", 1416252601, 0x013e0000u },
    { 195552, "01b6e6a56f6dd23f47b7372e7ffeea257275dec339b7a8c71a5aed731fddb741", 1416560791, 0x013c0000u },
    { 197568, "dceac96f67d433473da1c3f0105bd4ed69d6718c0b82e8c80b14374f50e5be0e", 1416860568, 0x013d0000u },
    { 199584, "ae2dbe6bd564e12c09e52d66dd2a746765e060d265cf34e7c39f3da0806785c3", 1417159303, 0x013e0000u },
    { 201600, "f48ec53f30948f00f6f84f9b46f1892bdadf5f2c370d5480a22dad7f4386ebf8", 1417468932, 0x013b0000u },
    { 203616, "b79db41020e90d30b773c44ab7fef3614c39b27e095cf71098fcf387087a82fd", 1417770184, 0x013a0000u },
    { 205632, "2aceb303162647b6b25df14751f4674a2a008281c7267498fbcd1a6feb417aa4", 1418053668, 0x0200fa00u },
    { 207648, "e261ab29ff148d149c6dbe289fb86df47e4d24a6a992b6f3fc3da82e52062ad7", 1418354351, 0x02010200u },
    { 209664, "6e50f77abb31b021c111b8d3e13a4de3ed85def8e0e3cad5ad98c21705c85346", 1418588813, 0x017b0000u },
    { 211680, "942fcb627d48913379ad278458a0edfbb86380d35186394785d5c1ee1a9b1418", 1418899396, 0x01680000u },
    { 213696, "2700f07f48f2265973152f970dbe4269994aa0fb0c1732857b3c8f4a764866be", 1419198151, 0x016b0000u },
    { 215712, "20936aee33ccc97ff0e054b3a4ca46b729196373de29c21c5406c4ee84beac89", 1419504291, 0x016b0000u },
    { 217728, "179e9cc56410ee1bb28906c5263f4d1ce218c0068b86adb6cb644381b71e2ac1", 1419803212, 0x01700000u },
    { 219744, "b46c3683b1d048a2d4fd369ba0d3f1701b577262525e678e70df29cac981a17f", 1420112082, 0x016a0000u },
    { 221760, "1acf4c31c5dd9720dd1ec27093b3a88fcc42a6635a466b4e66036bce683b3b63", 1420412157, 0x01670000u },
    { 223776, "eccbf6ecc1cf5d06d021c1464af5ba9c77374088405357910a330591e54c8a69", 1420717522, 0x01650000u },
    { 225792, "f2de96c03922852ea0d99fbf8a90f0abb7865e0825bbb2dc220ffa9454aaa1a8", 1421024655, 0x01620000u },
    { 227808, "3ea61300ffac592d0f4a4a3805276710313386a1ce8dd4bfb659ec30eed2106f", 1421331377, 0x01600000u },
    { 229824, "89539d0825461fc3c424a7955035a1c880074a995d3386e8c468c175ba234750", 1421632834, 0x015d0000u },
    { 231840, "0582e48dc31e1cc059ac78bde107a7f21b6a36aee2325ff761cbe0ccda99704f", 1421940507, 0x015a0000u },
    { 233856, "af7622e6f1f8ba7dc1563b8af296df717570246d270cb3433b4cb4598d46a83f", 1422244997, 0x01580000u },
    { 235872, "fed436a81b022ab90b1d43d419b9c70a16a159f0e5d68aa42eff5714413e8197", 1422545851, 0x01610000u },
    { 237888, "b9bad75e929b219838832b14e7e6184a0abbe750ba0fb8ff1b0844b2090dfd1d", 1422853669, 0x01560000u },
    { 239904, "3c290fb6540075de798f540ed11d134d8a63846214d7df488851553b90b9f8f6", 1423145346, 0x016e0000u },
    { 241920, "370909ac24e6bbbbbc423b6ff4d5fc88450e59535dfca30fcff9b2d479003773", 1423458533, 0x01550000u },
    { 243936, "1525e7594fe546cf55aef8d8d5c0d313c4e1f83be455bba3235151442331ce0a", 1423765127, 0x01530000u },
    { 245952, "48824458e6780a68426603fdb793c45d6919f5194c0ce0abcdd519d8e2552f48", 1424065564, 0x01530000u },
    { 247968, "20e14d676cb373534ad606d161a509ed6a7ea6ef57365cddeaf93cbdcec6d7e8", 1424373119, 0x01510000u },
    { 249984, "cc89247b8655ab219e647fb0f7cc9084e9121341fac63655b65a2e8fcc664ebb", 1424677357, 0x014e0000u },
    { 252000, "2018a3dc6524ec17f3a88ff033a6d87846bcf74435f4b45b0c2b2d51537f700a", 1424980160, 0x014f0000u },
    { 254016, "22276e36546fac305d0311fb3ec047c9611d8fe992a730c99ca3b1985bd76996", 1425285189, 0x014e0000u },
    { 256032, "c1d92c29ae09d8dc47d1858a10edf833741a9c1a4bc3dcdd431a0681e9b1e83d", 1425586107, 0x014e0000u },
    { 258048, "1a0678697aee699cefc9eb0f1f7a43654749035a5fa16a5724a3317cffa8dbf7", 1425885625, 0x01560000u },
    { 260064, "cc2133b8189ed9070c37485254ed61ddfaede6493671477841fa8c573b820955", 1426189348, 0x01530000u },
    { 262080, "cafd178119d95c530ee0a6bee21befa0c7589c9fade9b08b605af3175dd4c629", 1426498215, 0x01470000u },
    { 264096, "10501d7b8d6e284155ecd63422fa1032afc0a6573762b0135998542be80a8380", 1426791762, 0x01500000u },
    { 266112, "21af7caa7bb357dd0bdd61253fe54da1fb11e5932dbbc8e984c78552c6dde762", 1427085453, 0x01620000u },
    { 268128, "dbdd4253607819da366af20b722e28e89cd862fddbd61e5df87d0cfb83cbea89", 1427383705, 0x01690000u },
    { 270144, "83a0cd9644a7ec8417f735c981f2f2d01df88175026150151df0f0f46797a775", 1427679320, 0x01750000u },
    { 272160, "2e684b8eace0df8c7323588f72f0947ef34cda77aa96806e3113268b2f80aaff", 1427990828, 0x01630000u },
    { 274176, "9886ddd8d4225b2f3ad08d7b47a4d022499a4e5a19e3d0ed5aa1999019886536", 1428299811, 0x01580000u },
    { 276192, "cb65d5a278cd5a5f7e7a60d50bc84696531ef6e8096e7ed4c785212d2137a083", 1428606065, 0x01560000u },
    { 278208, "d2c15785cb86e3315f20a7f2dd3b09e37d4d8d6cf25a07b3069f57597715cf37", 1428912276, 0x01500000u },
    { 280224, "b7811c7f56cb7a82fcc68be20908e57d9d44e029fe57c42135558aaa2c0eb030", 1429206617, 0x01570000u },
    { 282240, "d2b5033b52e3b4e6ecbc9def07ae08d68825308b8564fc894c6f3cc698a1a480", 1429511596, 0x01570000u },
    { 284256, "3cf5062506130f0673cf59eae0e0ebd6af58a7b58ea00fe42d5be00155db8e1c", 1429801250, 0x016d0000u },
    { 286272, "6b95ddc7c3681daf4d8f39a9aed2fa44d59d3dd34af0097f66c90fab4d353a61", 1430123056, 0x014d0000u },
    { 288288, "e64d049c1df758a15f687609db243670fe7c2fea25b933f561fb64e0514f4380", 1430412773, 0x015c0000u },
    { 290304, "5a345d5b788681ea801b5a4667b17462cff06adba6f7b7ebfec3bd558648abb3", 1430726498, 0x01530000u },
    { 292320, "689b996ad787fe67b8dac63f2575b8f207656ad90fd44a4d01550479620c8df1", 1431030070, 0x01460000u },
    { 294336, "c832701fa9de7961434133fe47e641b9607c4014f3d35ee020e802e3868c7b5a", 1431331889, 0x014b0000u },
    { 296352, "2492fd29101a8d711f2fe36237668cdd4f0596d6ad6974cf93dbaaad82d344ae", 1431628510, 0x01530000u },
    { 298368, "12a415b17855e77facfba22b767cfd0afa4d96a9a19482ff532fae95748eeb51", 1431938726, 0x01450000u },
    { 300384, "ea1e5ea91be72bb2f0fdf5d90ebacff0056bc94191919c18be033c25de326860", 1432222439, 0x01640000u },
    { 302400, "7ccdcfe47f029aefbc86a98894ee5457c74186e4e36ba61185576fef65fb5d94", 1432503360, 0x0200b200u },
    { 304416, "c1846f97ca6497b9b51d0e88ae7fc08fefd9ae25412e6b9edcc16751e8bf187b", 1432804609, 0x0200d400u },
    { 306432, "e1e1ba78d207ac7eee4b89be3bf849b44572650769ed064f8f2cb7ba57fb1b29", 1433105037, 0x0200f900u },
    { 308448, "e5b1282d184a480819b10fbcd632cd7f005c57dfc5b6c2f0f4e5f6e32e360ccc", 1433398763, 0x02012700u },
    { 310464, "03cce8ebbfba45e96a236ccf571dcf0079f2b43623710ef641429b748f36078f", 1433687724, 0x02017600u },
    { 312480, "b3ea8d4e51249f0a0ee674edb26a1070fde2bc51aad0453e1a70d19ae5e378e1", 1433980337, 0x0201cf00u },
    { 314496, "f11528914d3e70342fc5a426052ce2fe15081a473a521cbd47a0bfa9a79f1136", 1434289075, 0x02018e00u },
    { 316512, "1f9f9579bbcaf0cd21384b43ecd273aa908d2326caa591c627b1375398a3d5ef", 1434586595, 0x0201c200u },
    { 318528, "b3e4fbcf0fa1c76d8c784ba651a9f5f4b7f21612609d4fdb3928fc3573a0183c", 1434889719, 0x0201b300u },
    { 320544, "a3a6c3900f8d80e355959c59a3354de419c2739b867e0abc71ef2703c09086bf", 1435192455, 0x0201b600u },
    { 322560, "fc239e5142825f6adefc7f62e168375d393c0fa73f341a0c7688bf5741c2edb8", 1435499722, 0x0201a500u },
    { 324576, "fddf2e098d8c92d3c096384a1b04b3ecc8c9b3d97908299ef5316e31b73ccec2", 1435805067, 0x02019500u },
    { 326592, "740c4b9e410f775dd65660c7df63bac4dc615200f1d7d43db5d6178f9c4acd4b", 1436115043, 0x02015400u },
    { 328608, "c02a29a141391826fe1d5417a9b5b44669df979ff0f19209775f82fb00f600ce", 1436404006, 0x0201b400u },
    { 330624, "a6ac7ed3a282e61aa31cfbbb4f20d9091a18beeb2af00aa7263a1adaa48059ca", 1436714278, 0x02016f00u },
    { 332640, "d39dfe7c7a57f4d50172d516f9ddc31f6f3af1c69dc74e06cefc75f73360e07e", 1437018582, 0x02013500u },
    { 334656, "f4d0db5496149c028eb266fbeb320c72aba766d881ae166dde52436c7129994b", 1437314124, 0x02014a00u },
    { 336672, "c0d082772b0772579772a75469e84c6de512423184ac05532653e8775c2c7f4b", 1437620054, 0x02015300u },
    { 338688, "8e66874bfd29e8a230ae3312c204f50b2c910fbb7c148c90a56e05104afab9ee", 1437916995, 0x02016300u },
    { 340704, "bf5d6956f8f0791a956fec79689c5e2cf334e10baa90b2b8abe3ad67ff2e81a2", 1438215115, 0x02017d00u },
    { 342720, "b1d194e3aa7b5d932d66c6724e9d8e7dd4f39dc5000f6230ba3d437a3d7354a2", 1438528644, 0x02014a00u },
    { 344736, "b4a03ec769eb6b8d585b98625d164dd8efdc7b137b21847149aa917c386c5187", 1438839797, 0x02012f00u },
    { 346752, "57e029895f505225c9edcb4e2e003234f1b7171c9b2bb3ac47a6a2b2f82629ac", 1439142805, 0x02010500u },
    { 348768, "8a7736ff9946ff0f907c151abd9f3b874da8f408685f0cc2b967ed42b6ad673b", 1439434018, 0x02011b00u },
    { 350784, "de88065359c7369e8f92e47a52b3aeaf59525e08f4b302e27edc8295e84deecb", 1439737093, 0x02011b00u },
    { 352800, "f76d7579d1c54620c4126a224ead527305c209eca78c8b2536e02d6e25ba8050", 1440036288, 0x02013f00u },
    { 354816, "1542287135dd0d178aecb90bbc80e9b6114c2125cbcf7e8c6c9d4d5214851b0e", 1440333663, 0x02016f00u },
    { 356832, "fdb55a562a142888a4a8ff9adb7aa9b61514637f6d5b523eb9e6b9ea7cd44a28", 1440632290, 0x02017400u },
    { 358848, "8a33b1aaa1f158cf94e095efea88ed3e04d83ffe5ce7929f0b4b5edd164b418b", 1440932264, 0x02020c00u },
    { 360864, "cb7a5ea24cf4edc315956597946b41fff5a499dfc07614a6ec3758e916c9476f", 1441230221, 0x0201cd00u },
    { 362880, "d377f5b9d7259c3e76ae3e811d193fa1753fa3f9b4f0b29755ac58fadd5cefab", 1441522257, 0x02023700u },
    { 364896, "d3970058bbde8f08df2bed2a5862044ad8cf4c50782b2ec7ce16a8e511f722b2", 1441834018, 0x0201e200u },
    { 366912, "508816ccbe961ecbfce0c6032aad375129677bae15edc78ca22645fde4fa5910", 1442137315, 0x0201f700u },
    { 368928, "3e918e48213063b46ac818975e310e47c65e42f59416fc956e62528714094372", 1442441838, 0x0201e700u },
    { 370944, "1935a4f5f81a147826a31e6b6e58ddb2bcc09e34bb6570f260ae918920f72f28", 1442743455, 0x02020200u },
    { 372960, "7c08a98d57fc43c379351147715e0d865a1ff876bcd99e966a7e3741e80bc370", 1443045574, 0x0201ff00u },
    { 374976, "8e947ba51ce663d38b864d9d414d8d5edf8686fba2c1c4d90680a374d79bdd9e", 1443351529, 0x0201e800u },
    { 376992, "60a1a74800713ed9617c14e4991d6117fd6e749e5ab3b1127c838b5e5c6732b7", 1443667660, 0x02016300u },
    { 379008, "3f9ae77c28837c3568055052b42fa268da94f277ecfff0147087438853d7fb9e", 1443972021, 0x02014e00u },
    { 381024, "124ccfd7acf8551be752aa2450e42d194f4f51d6974014035644b2b291a0ea79", 1444280658, 0x02013700u },
    { 383040, "c5bcbcd426ae687ac80154492e1cc1136207c2ed8e9094f2dd0e24ca99c09316", 1444582497, 0x02017600u },
    { 385056, "0f9c68cc30fc820f92bbbec5478366485396ba28678d2e65ef4e45ce4a3669f3", 1444888519, 0x02014600u },
    { 387072, "0c22f3bc78963d06306d3dac02df92a315e2291d1e5c03bc4044958f5de46d0f", 1445187729, 0x02015e00u },
    { 389088, "8acef5a8286383af3f5a5c8d125a42a4ed81b1dce6a94bc282104067bfefb838", 1445492835, 0x02015e00u },
    { 391104, "bb55a3b6aee711f21998221c7cb8d7df16667be8d3a16727bdc7a47a31151328", 1445791526, 0x02016100u },
    { 393120, "3dd831372262627b2a7e78c7992cf4e89e0c6022e975f1430b1ebc948834a2f4", 1446097961, 0x02014300u },
    { 395136, "2c5948c908b9feea7669bf2e0cb52e93725e90ccee5af95f9995a9e1355e4e63", 1446394603, 0x02018900u },
    { 397152, "bdffc6e50889080551a597ca86d6ee5d29ebcf0aa44d2a8ff68a43d0a00b70de", 1446697159, 0x02018e00u },
    { 399168, "8ad83097d8a75838ef7ba60a8e5ed6102d92d53f0619dc3e62ae9b4364a9fc2c", 1446995621, 0x0201b400u },
    { 401184, "ebd3af48e23ffec9b495f286faa74024ab6c68457989aab91763e9adbe2c314f", 1447310452, 0x02015e00u },
    { 403200, "0a57be0f57d34eb381782788af9f2232e3d975fd95032ee0d8c5c6632c38fc59", 1447616983, 0x02016a00u },
    { 405216, "46a53e8377e27cf93579b4ed407d6cac2a149244d4a46ca2d186f2cc208f6547", 1447929794, 0x02011e00u },
    { 407232, "71ed14bd18c7181b6a5667454d0b92dee8ea72fde5fdbd8f62d03f751cf77563", 1448223124, 0x02016200u },
    { 409248, "ae5d3b4950adfeb301d31367cb55092e70775a5b735960c403a0295e844b9639", 1448533413, 0x02013d00u },
    { 411264, "bc7f6083c95288736099b36a28fd2dbcb750ed64911d4e2ec7ab5738fa54658f", 1448828868, 0x02015700u },
    { 413280, "cd059910b0012b4be7d3aea87528f965521e9e8893cb48e61bd7aaf96b15a6c9", 1449134240, 0x02015500u },
    { 415296, "4982cf66de1782bc5d593b09dca161b96987dc0b8c4811e2f61482c3e2a23e2b", 1449432011, 0x02016a00u },
    { 417312, "3a3b1fbd758e2ea7618b2a9bda68c5b04f3d4b285e867f8b3e5552cb308a27b7", 1449736958, 0x02016400u },
    { 419328, "ceb45e1193fd38add522cab2126a414de8a050b48b8b1da0ef0e2e83a5a651b0", 1450025451, 0x0201fc00u },
    { 421344, "a3cb7564690953de0c39311693130960cd99933f3243a399c60a8a4a1a67dab6", 1450334504, 0x0201b500u },
    { 423360, "cb48175652429844fa8c3d89daff1c8ff413a94608bab9bc468f86fd00b2f945", 1450637434, 0x0201bf00u },
    { 425376, "9cd8f9b68a4738e09c613f8c644bffd49d29f990b7dbed22eddf43827c4d87b1", 1450946153, 0x0201aa00u },
    { 427392, "c245185c46959f5c9388397933be6d51f90b4ea63b5e71b8ddcf83cc13324731", 1451249756, 0x02019300u },
    { 429408, "66f10bb4d1399f6ecc215a848d8337661ff28ab7d67b66826279344b803994c3", 1451547336, 0x0201c500u },
    { 431424, "3ce4222066293f0b7f8915cfbd9cb9ae8770ee0e0c857aa4a53aefc2d30bf151", 1451854281, 0x02018200u },
    { 433440, "795b3e0543aa86afcc224f024de2741734b79aa31a6137728f67d2f32c52c397", 1452166250, 0x02013500u },
    { 435456, "07b6a1140f00845a2a0e755e518d230ddd8e2ef4cd5d1d1037862e3e180f8b4b", 1452469392, 0x02013b00u },
    { 437472, "c606c551b527cc1722bb522f2f024ca45c769178550dd432a01dddfd2cc52407", 1452772451, 0x02013800u },
    { 439488, "b88952504c96d39edb08b4092d5fc36566d3170ae983559ee5ad48dbc0a3b223", 1453076753, 0x02013a00u },
    { 441504, "0c1e561cbf6a318f3d5056733d3aad400cf85b3f514681ec4e345f5f95ebb8c3", 1453381844, 0x02013100u },
    { 443520, "00598f4e3715246c8a31d7df08ba25c51e0127c4cc61d7eb0a4153785ee60b92", 1453682866, 0x02014000u },
    { 445536, "0bdad1544568b78e0aaa5a8a1a73052fc3f5ae429ccc0a250d1f57026f5b6233", 1453960725, 0x0202bd00u },
    { 447552, "2eceeec1930f87fa3cce7f54c131705468a25a26b8773a306acf07570b25efc1", 1454279212, 0x0201e400u },
    { 449568, "8adccc81db336ff18bf89f12b797c1048ee89cf1d11c960acb086ea8aef09b3d", 1454574238, 0x02021300u },
    { 451584, "3ab2e63871d1cc7af991346f84929958f169d4c882f08e250779f53d0ea80abf", 1454872955, 0x02023d00u },
    { 453600, "d52b35150feba0dd737a304409abd2e4a5b45c6821c988f2e40c835aec7ca3e4", 1455182263, 0x0201f600u },
    { 455616, "b0cf6f552f3a85c92eed066bbaa7dc1ffb968ac359197ae45e41656ff4f99a7d", 1455487499, 0x0201ef00u },
    { 457632, "8e8f2e4e436a3d6bb652afaddac45d4cfa6cd8951836daed2677a2e9995396a2", 1455797120, 0x0201c200u },
    { 459648, "55eaf94c5cc19779da02a2c534620deb86a90ec4963ab79f8745fc4022c74356", 1456108890, 0x02016900u },
    { 461664, "96f23f6003d8374026734bb356cfba8bcda86212c8ce94122b5b0d1a3e5e9153", 1456408923, 0x02019200u },
    { 463680, "9481544e8379eb16335a00020073135ad09f1a09b9a920c98d41211905f34787", 1456723276, 0x02012a00u },
    { 465696, "9e102a9084658366bbb05672ece061398980f11d025722a0e5980db184d34364", 1457029234, 0x02012700u },
    { 467712, "6843fbe755731f333fa493b2aceb43a693a412aef351a95ebd7171a36128bc26", 1457324183, 0x02016300u },
    { 469728, "02fff3202a23a108df1e0fbb4ede1787b7246022e2cf594a0e3902db93aef5fa", 1457643446, 0x0200da00u },
    { 471744, "9cd422286c1a699e9935dd4b6ca52f1c80875cef956f7e329e4e58c7ebb2cac0", 1457949599, 0x0200d600u },
    { 473760, "dfd580a347d88baf9e75c70a0a08f32971d82f2b58270ac40e5c6e878c1eedbc", 1458236808, 0x02010500u },
    { 475776, "66d9919d0b59871d8c24d65f0a65335f7954895721bb356c49f04e61c505375c", 1458546085, 0x02010000u },
    { 477792, "a8aba158779d4a6e4e27476ab9b870927349780ef056c5bbc58538e8a55aa794", 1458838876, 0x02011f00u },
    { 479808, "bbda19d4c1fa3003ad7ee73d35efd94217830952ceffbe7dc37cc4f31c0e1d72", 1459147012, 0x02010800u },
    { 481824, "a8c54c9922fa88aedf97f80560547ec9e81aecda99dc055bdd6a90e1515f5899", 1459449367, 0x02010e00u },
    { 483840, "a4d2f0fa08708a3c9c9ca605fb0ae9c632d59b3010b1ad78a41ecb4762c00dba", 1459756903, 0x0200ea00u },
    { 485856, "1c949751a5b15793c8696840af05e00cb3b50e33a0f0ed4409227d62fa373c38", 1460053824, 0x02010100u },
    { 487872, "95cfc8f13eb737e8492e2862f6afd6c8110905acff8a9179a1c089cf1745fc2b", 1460354254, 0x02011b00u },
    { 489888, "8af603511f54b4a07ab9ca8052a462c9f58dcdac8294f9397c44b67456b25569", 1460648238, 0x02014d00u },
    { 491904, "b560000d7f75e24a6afae11a146a918e01027fbefc05941711e0bcfbcb4b3505", 1460945918, 0x02014c00u },
    { 493920, "d357d1445654d4442a3c5907370354a3c2c752c3363f17226454a0a7c16f7af2", 1461239711, 0x02019800u },
    { 495936, "c8c84d49dd1dbd0a28fd81125431aed61a62917ed4902253f5dd0ae26df3cdfe", 1461538272, 0x0201a800u },
    { 497952, "fe0b698726293d060dc2591769bc3210f7f76a5bd6114c42babb3066f9a71b66", 1461844818, 0x0201af00u },
    { 499968, "55ccc8e2f1b6cb2dcc249097b131678582cbe533274d4100e8552539a764c5e6", 1462147269, 0x0201a700u },
    { 501984, "fbdc81acfca3576870ebfe68574c0036ad31314e4cfb9ae5673bca11d829bff6", 1462455824, 0x02016e00u },
    { 504000, "d8b2067e30a88cf655cdc5f078da706f3f93420edf22deddd9c761fc2742922c", 1462758512, 0x02017700u },
    { 506016, "3c7f492ceada36cd9154c8f0b09d85e5ca7c29c056c89765912d18596893edda", 1463064669, 0x02015f00u },
    { 508032, "e54e88dd5aa29fd4ce0df71603f63898895b5089053a16366d6b7f521100d5ed", 1463370498, 0x02015500u },
    { 510048, "35f9f40ceb85e935df7d15590a10c903db6456fe43d97b60d996dfd47f82c222", 1463677219, 0x02013e00u },
    { 512064, "37baf12b0602ff9a24645d941ce227d28ef93550d9cf2c59df49c5b181a7965e", 1463986238, 0x02013300u },
    { 514080, "434ba4b011df62ba77223c56ea8da07da89c3d42a7aed74ba357cbcd0521c55b", 1464288734, 0x02013500u },
    { 516096, "ed9b7ced25e1291b2cacccf0c787a800fe548f71a4dd24c0b900dbfc6ddcdd13", 1464583832, 0x02015000u },
    { 518112, "70369eec24ac8b4258a04611c503e061af6482b858f405aee1197749f6c74bdb", 1464897296, 0x0200dc00u },
    { 520128, "6a27acc3e599f7598152f00eda601ec778a0cc06dca2ce70d3f2c0a762a41620", 1465201020, 0x0200f300u },
    { 522144, "0242ac3a22e20ecc14dfd64a4a3a9ae5a2b3a3ca80d805eb4afefb8f8db2de8c", 1465498066, 0x02011e00u },
    { 524160, "2575f42ccd2b93d8a3d958691d99a4cd3d3811bff80d4283730090806cbecb13", 1465792866, 0x02012000u },
    { 526176, "c7de4a324496c92280148b5b0a9ded10bbfcc5bb9d8277e430190374174fd8e4", 1466102598, 0x02010c00u },
    { 528192, "9abe309f733829fdd4cb57117703d0e68c5c8492415a9f3e8ca013bbe4e97b7b", 1466395457, 0x02013300u },
    { 530208, "6a3c11b24e1bd9e62ca595ac871b10564b214968ac5eda398457e9b7a47bfc81", 1466695578, 0x02014300u },
    { 532224, "bc275ee35624461e54634970b93254df50ecd03cce96346a26fa1dd9ce5a09cd", 1466993734, 0x02016000u },
    { 534240, "b09d43367e4b9982c6fbfeed82a136a9e79536c311ee79aea2bca53d58b92168", 1467280513, 0x0201cd00u },
    { 536256, "06af740a7e319a0872e215bd561d777b126c30e7dcbe3a66aabf75673ac30e1f", 1467590138, 0x0201b300u },
    { 538272, "18a08e6a47762f9703b17e918506e374b2e89054bdb9db32ac9659a84cc78c12", 1467876808, 0x02025f00u },
    { 540288, "26b88ffd4cd655db3898601a2dbc407533f750cbe2838b49a9722825d1b7578e", 1468184330, 0x02021800u },
    { 542304, "fdbb0aafe1c61b5ce2b51abebe6abdccf5fe9c5b82762e0ea9ea800d1e351bf0", 1468492155, 0x0201eb00u },
    { 544320, "55aa3bd74656930b747618a0ac9d2bba4f647624387ce4f10228614a156bbd66", 1468786774, 0x0201f000u },
    { 546336, "4ae7d25977debca934c1aa457990ff98e1cc548bc3d3fd5beff1f20902eac803", 1469093538, 0x0201af00u },
    { 548352, "32a40dfe7e9df789079c3621b108cc4c5b43d3f2753a7cddc03e7f2d29f3891d", 1469396461, 0x0201c600u },
    { 550368, "31e95795c2c7d8ddc051f1027805176e7e024bf774e8023d187e3a558d9b1588", 1469703239, 0x0201c600u },
    { 552384, "bd24e7b8b4a20c9978ebcc3b128a512366ffb30253d90a10b8c3606835c19bdc", 1470010854, 0x0201a800u },
    { 554400, "edefa700661697ff2b9855b5fc00a66d266e35d2e346aec3e21989774b0a1521", 1470310358, 0x0201b700u },
    { 556416, "eaa0acfce5c17bc2f6b84897ff25c0ad8d6abd25fd03d400e5e848d4acd12ef7", 1470609686, 0x0201bf00u },
    { 558432, "f91887a2f449acdf164af40c528030f101d641fab61c30e5fd698ddbf5d22447", 1470915055, 0x0201c100u },
    { 560448, "7286e29a1ad7da5f1f7eb93418db055f22a79adfaa89d608d9ba115101f682a6", 1471217733, 0x0201b700u },
    { 562464, "0531103b025cb6b66a50196abaca9fcd2b1dcd5cd4ceefe0b22aeb4aca629dc2", 1471509615, 0x02021c00u },
    { 564480, "3a318d6beccb13bc8d7c50bc87c4151a672c05023856ea3d05f1f588dd57db2d", 1471815101, 0x02020600u },
    { 566496, "458502e6e2377661f5fd138ae0546fe86b58f8d6dac2de7ee82f14555f3a54cb", 1472116093, 0x02022f00u },
    { 568512, "3a11552933ddd049bb19b798732141b37a3e31265e2ed9752349aa2114949b2b", 1472420866, 0x0201ff00u },
    { 570528, "edb5a1b3bb72862304591e20e2944f78c4228c0bd41ab9fcc5c9191d7ec3db8e", 1472720840, 0x02023600u },
    { 572544, "2ac7e99582f0f63fd11ff916657f9986f7e062884684315d66a439ce358aa672", 1473022093, 0x02024c00u },
    { 574560, "3dbdcf1a4e1e0c6e832715827c9f65dfe3f75075fff4e6fe4e9fd1051db6399f", 1473326007, 0x02024500u },
    { 576576, "64f6f750cf03456d9aff58603f4bd08c532240d025d47237ce0334a02863334b", 1473616272, 0x0202b800u },
    { 578592, "2a031d4adb9087f25f0dec9f8ba448670c7de1501f6205e1f998aeaf63ae02eb", 1473918207, 0x0202e500u },
    { 580608, "7cbe0c278a24a7946ceae3b60b3a04b18051fd636e027da4f067743e8f9d1261", 1474230836, 0x02027000u },
    { 582624, "1864e22997d2a7d685749951b5f98eaed62a8ca4b00545ef67c91feba308209d", 1474537320, 0x02023900u },
    { 584640, "166203b1c238e3351c77b9a8c4d19ee274b24cdaa28ccb355d68b3ac3f0da901", 1474847879, 0x0201eb00u },
    { 586656, "4dc0fa157f0770d409beb9d35859077adefddd88ac7821c646d54c82f650d093", 1475142753, 0x02022e00u },
    { 588672, "f38f621b5fe83d36d21d82cd766341d52f545bca01853edd63f98068ae428739", 1475443856, 0x02023c00u },
    { 590688, "c6e0bd0ffc87b18767a3dd5488ab949b6dc8b0b95b3329639cd0fe6f477bb55f", 1475736400, 0x02028800u },
    { 592704, "4f6ecdc26e1d61c42a9383fe5e9d4ac82d635059dc81622593e39fbaf03d174c", 1476031860, 0x02031300u },
    { 594720, "e2feb60e04c1a6f91bcc29c8a08741b2d4a278fa9f3f501cdb050ce37b2436a1", 1476333620, 0x02033d00u },
    { 596736, "639749c5e03652f32f422c81b6703348870e596b40d244128e395e2b8d551fdd", 1476638109, 0x02031c00u },
    { 598752, "583cc44367187cd10d05f3097461dd276fae43882e269e8102c8eb89861cc95a", 1476940604, 0x02034800u },
    { 600768, "c45f7d30958fe68fab79ec286cd8ad3fdcd6f9b984621a832606ebdb25d37a06", 1477240134, 0x02039d00u },
    { 602784, "51ca39486028ee90da64e3fb921f13eb3cd2c5e2d3c390226652c367fe92f6cc", 1477535485, 0x02043300u },
    { 604800, "595bc2d78e40a1c1ff17b81bbda5d7be88eaf733018080179cb705e7676a80a3", 1477855789, 0x02021c00u },
    { 606816, "a8896dcac9a731f021195975b152ee6aab9482609b5b60e4fd3be71e433f81a0", 1478169907, 0x02017100u },
    { 608832, "67a863314df1c3bcf15bdcc4bbddca51586377d05cc93f950ec7648404d0bf5f", 1478451994, 0x02023000u },
    { 610848, "65681b498dedb716f313667a0ac5b456ef62f97c0cf52824d49feac771865398", 1478750852, 0x02025800u },
    { 612864, "e6d12326fd0170b555aa26c05496e4fdda8146f1bb1d1956eba4365c48d6f3f0", 1479047376, 0x0202be00u },
    { 614880, "b3484974d8a8eb28f462129dd34e69c5fe9dd8d204c867d4eea8edaeba1a05d6", 1479345671, 0x0202e600u },
    { 616896, "40c26e238e43b92a8fa42334db09a0d3039a6ddb0684bb4d5a340f28c74b5155", 1479646716, 0x02034300u },
    { 618912, "c3d401ba6ca05cc59d8625b60253753a73099a6a1d64d5260f3ae83ebda76a9d", 1479955973, 0x0202d800u },
    { 620928, "3bd09a0a44f69007afc2120a3cb13955b0a76460a1c52681b4f086b8446f9310", 1480270501, 0x02025600u },
    { 622944, "a906c4be1f27b7686d839f3b1fab22361d27e5d14ff2499fc4c758219f163888", 1480574001, 0x02023e00u },
    { 624960, "b57a4ec3cd49d41ba7b5c0690084e8af91a73f506210399977c666fcad114800", 1480879933, 0x02023300u },
    { 626976, "5685623a3cbf744d4be528e3e366f47d68df596d815e6b1786c8acc8436f7b87", 1481171073, 0x0202bd00u },
    { 628992, "fb720417ef5c2147e029b64295e4bc01b48a98823be20dc98d76f202e6caef8b", 1481477283, 0x0202b700u },
    { 631008, "952be49849e1400cc13614a6479479ad1d0566976208e441d743ece63a4532d8", 1481778546, 0x0202cf00u },
    { 633024, "29070aa1d3e5d91b07b3a4d19f7f2db7ff3e414687612c964857809c160e3c9c", 1482074554, 0x02035e00u },
    { 635040, "b64bcb35e25516dea5a1ae90e24405b0ec7c5605860eb192e3b2195dd2dec867", 1482381539, 0x02031400u },
    { 637056, "1d33a36ddfca6ced015fc1188fae205fecc200bef0f43bb130dcd5811ba3bbc1", 1482680551, 0x02035b00u },
    { 639072, "c06e3415e82c3dea896d93df56211a6e911affd6647fcd33fb0949b9d57b98de", 1482991104, 0x0202a500u },
    { 641088, "457f1e467fc40ea544a44328acad00d1bb0654d12541f441a59cb29e6e3fa16c", 1483289827, 0x0202f600u },
};

static const char *dns_seeds[] = {
    "useast1.vtconline.org",  "uk1.vtconline.org",  "fr1.vtconline.org", "vtc.alwayshashing.com", "explorer.vertcoin.info",
    "p2pool.kosmoplovci.org", "crypto.office-on-the.net", "mail.hoosieryouth.org", "explorer.vertcoin.org",
    "dnsseed.meningslos.info", "ams1.vertcoin.org", "ams2.vertcoin.org", "ams3.vertcoin.org", "ams4.vertcoin.org",
    "nl1.vertcoin.org", "nl2.vertcoin.org", "se1.vertcoin.org", "ny.vertcoin.org", "la.vertcoin.org", "eu.vertcoin.org"

};

#endif

@interface BRPeerManager ()

@property (nonatomic, strong) NSMutableOrderedSet *peers;
@property (nonatomic, strong) NSMutableSet *connectedPeers, *misbehavinPeers, *nonFpTx;
@property (nonatomic, strong) BRPeer *downloadPeer;
@property (nonatomic, assign) uint32_t syncStartHeight, filterUpdateHeight;
@property (nonatomic, strong) BRBloomFilter *bloomFilter;
@property (nonatomic, assign) double fpRate;
@property (nonatomic, assign) NSUInteger taskId, connectFailures, misbehavinCount;
@property (nonatomic, assign) NSTimeInterval earliestKeyTime, lastRelayTime;
@property (nonatomic, strong) NSMutableDictionary *blocks, *orphans, *checkpoints, *txRelays, *txRequests;
@property (nonatomic, strong) NSMutableDictionary *publishedTx, *publishedCallback;
@property (nonatomic, strong) BRMerkleBlock *lastBlock, *lastOrphan;
@property (nonatomic, strong) dispatch_queue_t q;
@property (nonatomic, strong) id backgroundObserver, seedObserver;

@end

@implementation BRPeerManager

+ (instancetype)sharedInstance
{
    static id singleton = nil;
    static dispatch_once_t onceToken = 0;
    
    dispatch_once(&onceToken, ^{
        singleton = [self new];
    });
    
    return singleton;
}

- (instancetype)init
{
    if (! (self = [super init])) return nil;

    self.earliestKeyTime = [BRWalletManager sharedInstance].seedCreationTime;
    self.connectedPeers = [NSMutableSet set];
    self.misbehavinPeers = [NSMutableSet set];
    self.nonFpTx = [NSMutableSet set];
    self.taskId = UIBackgroundTaskInvalid;
    self.q = dispatch_queue_create("peermanager", NULL);
    self.orphans = [NSMutableDictionary dictionary];
    self.txRelays = [NSMutableDictionary dictionary];
    self.txRequests = [NSMutableDictionary dictionary];
    self.publishedTx = [NSMutableDictionary dictionary];
    self.publishedCallback = [NSMutableDictionary dictionary];

    self.backgroundObserver =
        [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil
        queue:nil usingBlock:^(NSNotification *note) {
            [self savePeers];
            [self saveBlocks];

            if (self.taskId == UIBackgroundTaskInvalid) {
                self.misbehavinCount = 0;
                [self.connectedPeers makeObjectsPerformSelector:@selector(disconnect)];
            }
        }];

    self.seedObserver =
        [[NSNotificationCenter defaultCenter] addObserverForName:BRWalletManagerSeedChangedNotification object:nil
        queue:nil usingBlock:^(NSNotification *note) {
            self.earliestKeyTime = [BRWalletManager sharedInstance].seedCreationTime;
            self.syncStartHeight = 0;
            [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
            [self.txRelays removeAllObjects];
            [self.publishedTx removeAllObjects];
            [self.publishedCallback removeAllObjects];
            [BRMerkleBlockEntity deleteObjects:[BRMerkleBlockEntity allObjects]];
            [BRMerkleBlockEntity saveContext];
            _blocks = nil;
            _bloomFilter = nil;
            _lastBlock = nil;
            [[self.connectedPeers copy] makeObjectsPerformSelector:@selector(disconnect)];
        }];

    return self;
}

- (void)dealloc
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    if (self.backgroundObserver) [[NSNotificationCenter defaultCenter] removeObserver:self.backgroundObserver];
    if (self.seedObserver) [[NSNotificationCenter defaultCenter] removeObserver:self.seedObserver];
}

- (NSMutableOrderedSet *)peers
{
    if (_peers.count >= PEER_MAX_CONNECTIONS) return _peers;

    @synchronized(self) {
        if (_peers.count >= PEER_MAX_CONNECTIONS) return _peers;
        _peers = [NSMutableOrderedSet orderedSet];

        [[BRPeerEntity context] performBlockAndWait:^{
            for (BRPeerEntity *e in [BRPeerEntity allObjects]) {
                @autoreleasepool {
                    if (e.misbehavin == 0) [_peers addObject:[e peer]];
                    else [self.misbehavinPeers addObject:[e peer]];
                }
            }
        }];

        [self sortPeers];

        // DNS peer discovery
        NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
        NSMutableArray *peers = [NSMutableArray arrayWithObject:[NSMutableArray array]];

        if (_peers.count < PEER_MAX_CONNECTIONS ||
            ((BRPeer *)_peers[PEER_MAX_CONNECTIONS - 1]).timestamp + 3*24*60*60 < now) {
            while (peers.count < sizeof(dns_seeds)/sizeof(*dns_seeds)) [peers addObject:[NSMutableArray array]];
        }
        
        if (peers.count > 0) {
            dispatch_apply(peers.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) {
                NSString *servname = @(BITCOIN_STANDARD_PORT).stringValue;
                struct addrinfo hints = { 0, AF_UNSPEC, SOCK_STREAM, 0, 0, 0, NULL, NULL }, *servinfo, *p;
                UInt128 addr = { .u32 = { 0, 0, CFSwapInt32HostToBig(0xffff), 0 } };

                NSLog(@"DNS lookup %s", dns_seeds[i]);
                
                if (getaddrinfo(dns_seeds[i], servname.UTF8String, &hints, &servinfo) == 0) {
                    for (p = servinfo; p != NULL; p = p->ai_next) {
                        if (p->ai_family == AF_INET) {
                            addr.u64[0] = 0;
                            addr.u32[2] = CFSwapInt32HostToBig(0xffff);
                            addr.u32[3] = ((struct sockaddr_in *)p->ai_addr)->sin_addr.s_addr;
                        }
//                        else if (p->ai_family == AF_INET6) {
//                            addr = *(UInt128 *)&((struct sockaddr_in6 *)p->ai_addr)->sin6_addr;
//                        }
                        else continue;
                        
                        uint16_t port = CFSwapInt16BigToHost(((struct sockaddr_in *)p->ai_addr)->sin_port);
                        NSTimeInterval age = 3*24*60*60 + arc4random_uniform(4*24*60*60); // add between 3 and 7 days
                    
                        [peers[i] addObject:[[BRPeer alloc] initWithAddress:addr port:port
                                             timestamp:(i > 0 ? now - age : now)
                                             services:SERVICES_NODE_NETWORK | SERVICES_NODE_BLOOM]];
                    }

                    freeaddrinfo(servinfo);
                }
            });
                        
            for (NSArray *a in peers) [_peers addObjectsFromArray:a];

#if BITCOIN_TESTNET
            [self sortPeers];
            return _peers;
#endif
            // if DNS peer discovery fails, fall back on a hard coded list of peers (list taken from satoshi client)
            if (_peers.count < PEER_MAX_CONNECTIONS) {
                UInt128 addr = { .u32 = { 0, 0, CFSwapInt32HostToBig(0xffff), 0 } };
            
                for (NSNumber *address in [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle]
                                           pathForResource:FIXED_PEERS ofType:@"plist"]]) {
                    // give hard coded peers a timestamp between 7 and 14 days ago
                    addr.u32[3] = CFSwapInt32HostToBig(address.unsignedIntValue);
                    [_peers addObject:[[BRPeer alloc] initWithAddress:addr port:BITCOIN_STANDARD_PORT
                     timestamp:now - (7*24*60*60 + arc4random_uniform(7*24*60*60))
                     services:SERVICES_NODE_NETWORK | SERVICES_NODE_BLOOM]];
                }
            }
            
            [self sortPeers];
        }

        return _peers;
    }
}

- (NSMutableDictionary *)blocks
{
    if (_blocks.count > 0) return _blocks;

    [[BRMerkleBlockEntity context] performBlockAndWait:^{
        if (_blocks.count > 0) return;
        _blocks = [NSMutableDictionary dictionary];
        self.checkpoints = [NSMutableDictionary dictionary];

        for (int i = 0; i < CHECKPOINT_COUNT; i++) { // add checkpoints to the block collection
            UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;

            _blocks[uint256_obj(hash)] = [[BRMerkleBlock alloc] initWithBlockHash:hash version:1 prevBlock:UINT256_ZERO
                                          merkleRoot:UINT256_ZERO timestamp:checkpoint_array[i].timestamp
                                          target:checkpoint_array[i].target nonce:0 totalTransactions:0 hashes:nil
                                          flags:nil height:checkpoint_array[i].height];
            self.checkpoints[@(checkpoint_array[i].height)] = uint256_obj(hash);
        }

        for (BRMerkleBlockEntity *e in [BRMerkleBlockEntity allObjects]) {
            @autoreleasepool {
                BRMerkleBlock *b = e.merkleBlock;

                if (b) _blocks[uint256_obj(b.blockHash)] = b;
            }
        };
    }];

    return _blocks;
}

// this is used as part of a getblocks or getheaders request
- (NSArray *)blockLocatorArray
{
    // append 10 most recent block hashes, decending, then continue appending, doubling the step back each time,
    // finishing with the genesis block (top, -1, -2, -3, -4, -5, -6, -7, -8, -9, -11, -15, -23, -39, -71, -135, ..., 0)
    NSMutableArray *locators = [NSMutableArray array];
    int32_t step = 1, start = 0;
    BRMerkleBlock *b = self.lastBlock;

    while (b && b.height > 0) {
        [locators addObject:uint256_obj(b.blockHash)];
        if (++start >= 10) step *= 2;

        for (int32_t i = 0; b && i < step; i++) {
            b = self.blocks[uint256_obj(b.prevBlock)];
        }
    }

    [locators addObject:uint256_obj(GENESIS_BLOCK_HASH)];
    return locators;
}

- (BRMerkleBlock *)lastBlock
{
    if (! _lastBlock) {
        NSFetchRequest *req = [BRMerkleBlockEntity fetchReq];

        req.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"height" ascending:NO]];
        req.predicate = [NSPredicate predicateWithFormat:@"height >= 0 && height != %d", BLOCK_UNKNOWN_HEIGHT];
        req.fetchLimit = 1;
        _lastBlock = [[BRMerkleBlockEntity fetchObjects:req].lastObject merkleBlock];
        
        // if we don't have any blocks yet, use the latest checkpoint that's at least a week older than earliestKeyTime
        for (int i = CHECKPOINT_COUNT - 1; ! _lastBlock && i >= 0; i--) {
            if (i == 0 || checkpoint_array[i].timestamp + 7*24*60*60 < self.earliestKeyTime + NSTimeIntervalSince1970) {
                UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;
                
                _lastBlock = [[BRMerkleBlock alloc] initWithBlockHash:hash version:1 prevBlock:UINT256_ZERO
                              merkleRoot:UINT256_ZERO timestamp:checkpoint_array[i].timestamp
                              target:checkpoint_array[i].target nonce:0 totalTransactions:0 hashes:nil flags:nil
                              height:checkpoint_array[i].height];
            }
        }
        
        if (_lastBlock.height > _estimatedBlockHeight) _estimatedBlockHeight = _lastBlock.height;
    }
    
    return _lastBlock;
}

- (uint32_t)lastBlockHeight
{
    return self.lastBlock.height;
}

- (double)syncProgress
{
    if (! self.downloadPeer && self.syncStartHeight == 0) return 0.0;
    if (self.downloadPeer.status != BRPeerStatusConnected) return 0.05;
    if (self.lastBlockHeight >= self.estimatedBlockHeight) return 1.0;
    return 0.1 + 0.9*(self.lastBlockHeight - self.syncStartHeight)/(self.estimatedBlockHeight - self.syncStartHeight);
}

// number of connected peers
- (NSUInteger)peerCount
{
    NSUInteger count = 0;

    for (BRPeer *peer in [self.connectedPeers copy]) {
        if (peer.status == BRPeerStatusConnected) count++;
    }

    return count;
}

- (NSString *)downloadPeerName
{
    return [self.downloadPeer.host stringByAppendingFormat:@":%d", self.downloadPeer.port];
}

- (BRBloomFilter *)bloomFilterForPeer:(BRPeer *)peer
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    
    // every time a new wallet address is added, the bloom filter has to be rebuilt, and each address is only used for
    // one transaction, so here we generate some spare addresses to avoid rebuilding the filter each time a wallet
    // transaction is encountered during the blockchain download
    [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_EXTERNAL + 100 internal:NO];
    [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_INTERNAL + 100 internal:YES];

    [self.orphans removeAllObjects]; // clear out orphans that may have been received on an old filter
    self.lastOrphan = nil;
    self.filterUpdateHeight = self.lastBlockHeight;
    self.fpRate = BLOOM_REDUCED_FALSEPOSITIVE_RATE;

    BRUTXO o;
    NSData *d;
    NSSet *addresses = [manager.wallet.allReceiveAddresses setByAddingObjectsFromSet:manager.wallet.allChangeAddresses];
    NSUInteger i, elemCount = addresses.count + manager.wallet.unspentOutputs.count;
    NSMutableArray *inputs = [NSMutableArray new];

    for (BRTransaction *tx in manager.wallet.allTransactions) { // find TXOs spent within the last 100 blocks
        [self addTransactionToPublishList:tx]; // also populate the tx publish list
        if (tx.blockHeight != TX_UNCONFIRMED && tx.blockHeight + 100 < self.lastBlockHeight) break;
        i = 0;
        
        for (NSValue *hash in tx.inputHashes) {
            [hash getValue:&o.hash];
            o.n = [tx.inputIndexes[i++] unsignedIntValue];
            
            BRTransaction *t = [manager.wallet transactionForHash:o.hash];
            
            if (o.n < t.outputAddresses.count && [manager.wallet containsAddress:t.outputAddresses[o.n]]) {
                [inputs addObject:brutxo_data(o)];
                elemCount++;
            }
        }
    }
    
    BRBloomFilter *filter = [[BRBloomFilter alloc] initWithFalsePositiveRate:self.fpRate
                             forElementCount:(elemCount < 200 ? 300 : elemCount + 100) tweak:(uint32_t)peer.hash
                             flags:BLOOM_UPDATE_ALL];

    for (NSString *addr in addresses) {// add addresses to watch for tx receiveing money to the wallet
        NSData *hash = addr.addressToHash160;

        if (hash && ! [filter containsData:hash]) [filter insertData:hash];
    }

    for (NSValue *utxo in manager.wallet.unspentOutputs) { // add UTXOs to watch for tx sending money from the wallet
        [utxo getValue:&o];
        d = brutxo_data(o);
        if (! [filter containsData:d]) [filter insertData:d];
    }
    
    for (d in inputs) { // also add TXOs spent within the last 100 blocks
        if (! [filter containsData:d]) [filter insertData:d];
    }
    
    // TODO: XXXX if already synced, recursively add inputs of unconfirmed receives
    _bloomFilter = filter;
    return _bloomFilter;
}

- (void)connect
{
    dispatch_async(self.q, ^{
        if ([BRWalletManager sharedInstance].noWallet) return; // check to make sure the wallet has been created
        if (self.connectFailures >= MAX_CONNECT_FAILURES) self.connectFailures = 0; // this attempt is a manual retry
    
        if (self.syncProgress < 1.0) {
            if (self.syncStartHeight == 0) {
                self.syncStartHeight = (uint32_t)[[NSUserDefaults standardUserDefaults]
                                                  integerForKey:SYNC_STARTHEIGHT_KEY];
            }
            
            if (self.syncStartHeight == 0) {
                self.syncStartHeight = self.lastBlockHeight;
                [[NSUserDefaults standardUserDefaults] setInteger:self.syncStartHeight forKey:SYNC_STARTHEIGHT_KEY];
            }

            if (self.taskId == UIBackgroundTaskInvalid) { // start a background task for the chain sync
                self.taskId =
                    [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
                        dispatch_async(self.q, ^{
                            [self saveBlocks];
                        });

                        [self syncStopped];
                    }];
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncStartedNotification
                 object:nil];
            });
        }

        [self.connectedPeers minusSet:[self.connectedPeers objectsPassingTest:^BOOL(id obj, BOOL *stop) {
            return ([obj status] == BRPeerStatusDisconnected) ? YES : NO;
        }]];

        if (self.connectedPeers.count >= PEER_MAX_CONNECTIONS) return; //already connected to PEER_MAX_CONNECTIONS peers

        NSMutableOrderedSet *peers = [NSMutableOrderedSet orderedSetWithOrderedSet:self.peers];

        if (peers.count > 100) [peers removeObjectsInRange:NSMakeRange(100, peers.count - 100)];

        while (peers.count > 0 && self.connectedPeers.count < PEER_MAX_CONNECTIONS) {
            // pick a random peer biased towards peers with more recent timestamps
            BRPeer *p = peers[(NSUInteger)(pow(arc4random_uniform((uint32_t)peers.count), 2)/peers.count)];

            if (p && ! [self.connectedPeers containsObject:p]) {
                [p setDelegate:self queue:self.q];
                p.earliestKeyTime = self.earliestKeyTime;
                [self.connectedPeers addObject:p];
                [p connect];
            }

            [peers removeObject:p];
        }

        if (self.connectedPeers.count == 0) {
            [self syncStopped];

            dispatch_async(dispatch_get_main_queue(), ^{
                NSError *error = [NSError errorWithDomain:@"BreadWallet" code:1
                                  userInfo:@{NSLocalizedDescriptionKey:NSLocalizedString(@"no peers found", nil)}];

                [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncFailedNotification
                 object:nil userInfo:@{@"error":error}];
            });
        }
    });
}

// rescans blocks and transactions after earliestKeyTime, a new random download peer is also selected due to the
// possibility that a malicious node might lie by omitting transactions that match the bloom filter
- (void)rescan
{
    if (! self.connected) return;

    dispatch_async(self.q, ^{
        _lastBlock = nil;

        // start the chain download from the most recent checkpoint that's at least a week older than earliestKeyTime
        for (int i = CHECKPOINT_COUNT - 1; ! _lastBlock && i >= 0; i--) {
            if (i == 0 || checkpoint_array[i].timestamp + 7*24*60*60 < self.earliestKeyTime + NSTimeIntervalSince1970) {
                UInt256 hash = *(UInt256 *)@(checkpoint_array[i].hash).hexToData.reverse.bytes;

                _lastBlock = self.blocks[uint256_obj(hash)];
            }
        }

        if (self.downloadPeer) { // disconnect the current download peer so a new random one will be selected
            [self.peers removeObject:self.downloadPeer];
            [self.downloadPeer disconnect];
        }

        self.syncStartHeight = self.lastBlockHeight;
        [[NSUserDefaults standardUserDefaults] setInteger:self.syncStartHeight forKey:SYNC_STARTHEIGHT_KEY];
        [self connect];
    });
}

// adds transaction to list of tx to be published, along with any unconfirmed inputs
- (void)addTransactionToPublishList:(BRTransaction *)transaction
{
    if (transaction.blockHeight == TX_UNCONFIRMED) {
        NSLog(@"[BRPeerManager] add transaction to publish list %@", transaction);
        self.publishedTx[uint256_obj(transaction.txHash)] = transaction;
    
        for (NSValue *hash in transaction.inputHashes) {
            UInt256 h = UINT256_ZERO;
            
            [hash getValue:&h];
            [self addTransactionToPublishList:[[BRWalletManager sharedInstance].wallet transactionForHash:h]];
        }
    }
}

- (void)publishTransaction:(BRTransaction *)transaction completion:(void (^)(NSError *error))completion
{
    NSLog(@"[BRPeerManager] publish transaction %@", transaction);
    if (! transaction.isSigned) {
        if (completion) {
            [[BREventManager sharedEventManager] saveEvent:@"peer_manager:not_signed"];
            completion([NSError errorWithDomain:@"BreadWallet" code:401 userInfo:@{NSLocalizedDescriptionKey:
                        NSLocalizedString(@"vertcoin transaction not signed", nil)}]);
        }
        
        return;
    }
    else if (! self.connected && self.connectFailures >= MAX_CONNECT_FAILURES) {
        if (completion) {
            [[BREventManager sharedEventManager] saveEvent:@"peer_manager:not_connected"];
            completion([NSError errorWithDomain:@"BreadWallet" code:-1009 userInfo:@{NSLocalizedDescriptionKey:
                        NSLocalizedString(@"not connected to the vertcoin network", nil)}]);
        }
        
        return;
    }

    NSMutableSet *peers = [NSMutableSet setWithSet:self.connectedPeers];
    NSValue *hash = uint256_obj(transaction.txHash);
    
    [self addTransactionToPublishList:transaction];
    if (completion) self.publishedCallback[hash] = completion;

    NSArray *txHashes = self.publishedTx.allKeys;

    // instead of publishing to all peers, leave out the download peer to see if the tx propogates and gets relayed back
    // TODO: XXX connect to a random peer with an empty or fake bloom filter just for publishing
    if (self.peerCount > 1 && self.downloadPeer) [peers removeObject:self.downloadPeer];

    dispatch_async(dispatch_get_main_queue(), ^{
        [self performSelector:@selector(txTimeout:) withObject:hash afterDelay:PROTOCOL_TIMEOUT];

        for (BRPeer *p in peers) {
            if (p.status != BRPeerStatusConnected) continue;
            [p sendInvMessageWithTxHashes:txHashes];
            [p sendPingMessageWithPongHandler:^(BOOL success) {
                if (! success) return;

                for (NSValue *h in txHashes) {
                    if ([self.txRelays[h] containsObject:p] || [self.txRequests[h] containsObject:p]) continue;
                    if (! self.txRequests[h]) self.txRequests[h] = [NSMutableSet set];
                    [self.txRequests[h] addObject:p];
                    [p sendGetdataMessageWithTxHashes:@[h] andBlockHashes:nil];
                }
            }];
        }
    });
}

// number of connected peers that have relayed the transaction
- (NSUInteger)relayCountForTransaction:(UInt256)txHash
{
    return [self.txRelays[uint256_obj(txHash)] count];
}

// seconds since reference date, 00:00:00 01/01/01 GMT
// NOTE: this is only accurate for the last two weeks worth of blocks, other timestamps are estimated from checkpoints
- (NSTimeInterval)timestampForBlockHeight:(uint32_t)blockHeight
{
    if (blockHeight == TX_UNCONFIRMED) return (self.lastBlock.timestamp - NSTimeIntervalSince1970) + 10*60; //next block

    if (blockHeight >= self.lastBlockHeight) { // future block, assume 10 minutes per block after last block
        return (self.lastBlock.timestamp - NSTimeIntervalSince1970) + (blockHeight - self.lastBlockHeight)*10*60;
    }

    if (_blocks.count > 0) {
        if (blockHeight >= self.lastBlockHeight - nInterval*2) { // recent block we have the header for
            BRMerkleBlock *block = self.lastBlock;

            while (block && block.height > blockHeight) block = self.blocks[uint256_obj(block.prevBlock)];
            if (block) return block.timestamp - NSTimeIntervalSince1970;
        }
    }
    else [[BRMerkleBlockEntity context] performBlock:^{ [self blocks]; }];

    uint32_t h = self.lastBlockHeight, t = self.lastBlock.timestamp;

    for (int i = CHECKPOINT_COUNT - 1; i >= 0; i--) { // estimate from checkpoints
        if (checkpoint_array[i].height <= blockHeight) {
            t = checkpoint_array[i].timestamp + (t - checkpoint_array[i].timestamp)*
                (blockHeight - checkpoint_array[i].height)/(h - checkpoint_array[i].height);
            return t - NSTimeIntervalSince1970;
        }

        h = checkpoint_array[i].height;
        t = checkpoint_array[i].timestamp;
    }

    return checkpoint_array[0].timestamp - NSTimeIntervalSince1970;
}

- (void)setBlockHeight:(int32_t)height andTimestamp:(NSTimeInterval)timestamp forTxHashes:(NSArray *)txHashes
{
    NSArray *updatedTx = [[BRWalletManager sharedInstance].wallet setBlockHeight:height andTimestamp:timestamp
                          forTxHashes:txHashes];
    
    if (height != TX_UNCONFIRMED) { // remove confirmed tx from publish list and relay counts
        [self.publishedTx removeObjectsForKeys:txHashes];
        [self.publishedCallback removeObjectsForKeys:txHashes];
        [self.txRelays removeObjectsForKeys:txHashes];
    }
    
    for (NSValue *hash in updatedTx) {
        NSError *kvErr = nil;
        BRTxMetadataObject *txm;
        UInt256 h;
        
        [hash getValue:&h];
        txm = [[BRTxMetadataObject alloc] initWithTxHash:h store:[BRAPIClient sharedClient].kv];
        txm.blockHeight = height;
        if (txm) [[BRAPIClient sharedClient].kv set:txm error:&kvErr];
    }
}

- (void)txTimeout:(NSValue *)txHash
{
    void (^callback)(NSError *error) = self.publishedCallback[txHash];

    [self.publishedTx removeObjectForKey:txHash];
    [self.publishedCallback removeObjectForKey:txHash];
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:txHash];

    if (callback) {
        [[BREventManager sharedEventManager] saveEvent:@"peer_manager:tx_canceled_timeout"];
        callback([NSError errorWithDomain:@"BreadWallet" code:BITCOIN_TIMEOUT_CODE userInfo:@{NSLocalizedDescriptionKey:
                  NSLocalizedString(@"transaction canceled, network timeout", nil)}]);
    }
}

- (void)syncTimeout
{
    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];

    if (now - self.lastRelayTime < PROTOCOL_TIMEOUT) { // the download peer relayed something in time, so restart timer
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];
        [self performSelector:@selector(syncTimeout) withObject:nil
         afterDelay:PROTOCOL_TIMEOUT - (now - self.lastRelayTime)];
        return;
    }

    dispatch_async(self.q, ^{
        if (! self.downloadPeer) return;
        NSLog(@"%@:%d chain sync timed out", self.downloadPeer.host, self.downloadPeer.port);
        [self.peers removeObject:self.downloadPeer];
        [self.downloadPeer disconnect];
    });
}

- (void)syncStopped
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];

        if (self.taskId != UIBackgroundTaskInvalid) {
            [[UIApplication sharedApplication] endBackgroundTask:self.taskId];
            self.taskId = UIBackgroundTaskInvalid;
        }
    });
}

- (void)loadMempools
{
    for (BRPeer *p in self.connectedPeers) { // after syncing, load filters and get mempools from other peers
        if (p.status != BRPeerStatusConnected) continue;
        
        if (p != self.downloadPeer || self.fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*5.0) {
            [p sendFilterloadMessage:[self bloomFilterForPeer:p].data];
        }
        
        [p sendInvMessageWithTxHashes:self.publishedCallback.allKeys]; // publish pending tx
        [p sendPingMessageWithPongHandler:^(BOOL success) {
            if (success) {
                [p sendMempoolMessage:self.publishedTx.allKeys completion:^(BOOL success) {
                    if (success) {
                        p.synced = YES;
                        [self removeUnrelayedTransactions];
                        [p sendGetaddrMessage]; // request a list of other bitcoin peers
                        
                        dispatch_async(dispatch_get_main_queue(), ^{
                            [[NSNotificationCenter defaultCenter]
                             postNotificationName:BRPeerManagerTxStatusNotification object:nil];
                        });
                    }
                    
                    if (p == self.downloadPeer) {
                        [self syncStopped];

                        dispatch_async(dispatch_get_main_queue(), ^{
                            [[NSNotificationCenter defaultCenter]
                             postNotificationName:BRPeerManagerSyncFinishedNotification object:nil];
                        });
                    }
                }];
            }
            else if (p == self.downloadPeer) {
                [self syncStopped];

                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter]
                     postNotificationName:BRPeerManagerSyncFinishedNotification object:nil];
                });
            }
        }];
    }
}

// unconfirmed transactions that aren't in the mempools of any of connected peers have likely dropped off the network
- (void)removeUnrelayedTransactions
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    BOOL rescan = NO, notify = NO;
    NSValue *hash;
    UInt256 h;

    // don't remove transactions until we're connected to PEER_MAX_CONNECTION peers
    if (self.peerCount < PEER_MAX_CONNECTIONS) return;
    
    for (BRPeer *p in self.connectedPeers) { // don't remove tx until all peers have finished relaying their mempools
        if (! p.synced) return;
    }

    for (BRTransaction *tx in manager.wallet.allTransactions) {
        if (tx.blockHeight != TX_UNCONFIRMED) break;
        hash = uint256_obj(tx.txHash);
        if (self.publishedCallback[hash] != NULL) continue;
        
        if ([self.txRelays[hash] count] == 0 && [self.txRequests[hash] count] == 0) {
            // if this is for a transaction we sent, and it wasn't already known to be invalid, notify user of failure
            if (! rescan && [manager.wallet amountSentByTransaction:tx] > 0 && [manager.wallet transactionIsValid:tx]) {
                NSLog(@"failed transaction %@", tx);
                rescan = notify = YES;
                
                for (NSValue *hash in tx.inputHashes) { // only recommend a rescan if all inputs are confirmed
                    [hash getValue:&h];
                    if ([manager.wallet transactionForHash:h].blockHeight != TX_UNCONFIRMED) continue;
                    rescan = NO;
                    break;
                }
            }
            
            [manager.wallet removeTransaction:tx.txHash];
        }
        else if ([self.txRelays[hash] count] < PEER_MAX_CONNECTIONS) {
            // set timestamp 0 to mark as unverified
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:@[hash]];
        }
    }
    
    if (notify) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (rescan) {
                [[BREventManager sharedEventManager] saveEvent:@"peer_manager:tx_rejected_rescan"];
                [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@"transaction rejected", nil)
                  message:NSLocalizedString(@"Your wallet may be out of sync.\n"
                                            "This can often be fixed by rescanning the blockchain.", nil) delegate:self
                  cancelButtonTitle:NSLocalizedString(@"cancel", nil)
                  otherButtonTitles:NSLocalizedString(@"rescan", nil), nil] show];
            }
            else {
                [[BREventManager sharedEventManager] saveEvent:@"peer_manager_tx_rejected"];
                [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@"transaction rejected", nil)
                  message:nil delegate:nil cancelButtonTitle:NSLocalizedString(@"ok", nil) otherButtonTitles:nil] show];
            }
        });
    }
}

- (void)updateFilter
{
    if (self.downloadPeer.needsFilterUpdate) return;
    self.downloadPeer.needsFilterUpdate = YES;
    NSLog(@"filter update needed, waiting for pong");
    
    [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so we include already sent tx
        if (! success) return;
        NSLog(@"updating filter with newly created wallet addresses");
        _bloomFilter = nil;

        if (self.lastBlockHeight < self.estimatedBlockHeight) { // if we're syncing, only update download peer
            [self.downloadPeer sendFilterloadMessage:[self bloomFilterForPeer:self.downloadPeer].data];
            [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so filter is loaded
                if (! success) return;
                self.downloadPeer.needsFilterUpdate = NO;
                [self.downloadPeer rerequestBlocksFrom:self.lastBlock.blockHash];
                [self.downloadPeer sendPingMessageWithPongHandler:^(BOOL success) {
                    if (! success || self.downloadPeer.needsFilterUpdate) return;
                    [self.downloadPeer sendGetblocksMessageWithLocators:[self blockLocatorArray]
                     andHashStop:UINT256_ZERO];
                }];
            }];
        }
        else {
            for (BRPeer *p in self.connectedPeers) {
                if (p.status != BRPeerStatusConnected) continue;
                [p sendFilterloadMessage:[self bloomFilterForPeer:p].data];
                [p sendPingMessageWithPongHandler:^(BOOL success) { // wait for pong so we know filter is loaded
                    if (! success) return;
                    p.needsFilterUpdate = NO;
                    [p sendMempoolMessage:self.publishedTx.allKeys completion:nil];
                }];
            }
        }
    }];
}

- (void)peerMisbehavin:(BRPeer *)peer
{
    peer.misbehavin++;
    [self.peers removeObject:peer];
    [self.misbehavinPeers addObject:peer];

    if (++self.misbehavinCount >= 10) { // clear out stored peers so we get a fresh list from DNS for next connect
        self.misbehavinCount = 0;
        [self.misbehavinPeers removeAllObjects];
        [BRPeerEntity deleteObjects:[BRPeerEntity allObjects]];
        _peers = nil;
    }
    
    [peer disconnect];
    [self connect];
}

- (void)sortPeers
{
    [_peers sortUsingComparator:^NSComparisonResult(BRPeer *p1, BRPeer *p2) {
        if (p1.timestamp > p2.timestamp) return NSOrderedAscending;
        if (p1.timestamp < p2.timestamp) return NSOrderedDescending;
        return NSOrderedSame;
    }];
}

- (void)savePeers
{
    NSLog(@"[BRPeerManager] save peers");
    NSMutableSet *peers = [[self.peers.set setByAddingObjectsFromSet:self.misbehavinPeers] mutableCopy];
    NSMutableSet *addrs = [NSMutableSet set];

    for (BRPeer *p in peers) {
        if (p.address.u64[0] != 0 || p.address.u32[2] != CFSwapInt32HostToBig(0xffff)) continue; // skip IPv6 for now
        [addrs addObject:@(CFSwapInt32BigToHost(p.address.u32[3]))];
    }

    [[BRPeerEntity context] performBlock:^{
        [BRPeerEntity deleteObjects:[BRPeerEntity objectsMatching:@"! (address in %@)", addrs]]; // remove deleted peers

        for (BRPeerEntity *e in [BRPeerEntity objectsMatching:@"address in %@", addrs]) { // update existing peers
            @autoreleasepool {
                BRPeer *p = [peers member:[e peer]];
                
                if (p) {
                    e.timestamp = p.timestamp;
                    e.services = p.services;
                    e.misbehavin = p.misbehavin;
                    [peers removeObject:p];
                }
                else [e deleteObject];
            }
        }

        for (BRPeer *p in peers) {
            @autoreleasepool {
                [[BRPeerEntity managedObject] setAttributesFromPeer:p]; // add new peers
            }
        }
    }];
}

- (void)saveBlocks
{
    NSLog(@"[BRPeerManager] save blocks");
    NSMutableDictionary *blocks = [NSMutableDictionary dictionary];
    BRMerkleBlock *b = self.lastBlock;

    while (b) {
        blocks[[NSData dataWithBytes:b.blockHash.u8 length:sizeof(UInt256)]] = b;
        b = self.blocks[uint256_obj(b.prevBlock)];
    }

    [[BRMerkleBlockEntity context] performBlock:^{
        [BRMerkleBlockEntity deleteObjects:[BRMerkleBlockEntity objectsMatching:@"! (blockHash in %@)",
                                            blocks.allKeys]];

        for (BRMerkleBlockEntity *e in [BRMerkleBlockEntity objectsMatching:@"blockHash in %@", blocks.allKeys]) {
            @autoreleasepool {
                [e setAttributesFromBlock:blocks[e.blockHash]];
                [blocks removeObjectForKey:e.blockHash];
            }
        }

        for (BRMerkleBlock *b in blocks.allValues) {
            @autoreleasepool {
                [[BRMerkleBlockEntity managedObject] setAttributesFromBlock:b];
            }
        }
        
        [BRMerkleBlockEntity saveContext];
    }];
}

// MARK: - BRPeerDelegate

- (void)peerConnected:(BRPeer *)peer
{
    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];
    
    if (peer.timestamp > now + 2*60*60 || peer.timestamp < now - 2*60*60) peer.timestamp = now; //timestamp sanity check
    self.connectFailures = 0;
    NSLog(@"%@:%d connected with lastblock %d", peer.host, peer.port, peer.lastblock);
    
    // drop peers that don't carry full blocks, or aren't synced yet
    // TODO: XXXX does this work with 0.11 pruned nodes?
    if (! (peer.services & SERVICES_NODE_NETWORK) || peer.lastblock + 10 < self.lastBlockHeight) {
        [peer disconnect];
        return;
    }

    // drop peers that don't support SPV filtering
    if (peer.version >= 70011 && ! (peer.services & SERVICES_NODE_BLOOM)) {
        [peer disconnect];
        return;
    }

    if (self.connected && (self.estimatedBlockHeight >= peer.lastblock || self.lastBlockHeight >= peer.lastblock)) {
        if (self.lastBlockHeight < self.estimatedBlockHeight) return; // don't load bloom filter yet if we're syncing
        [peer sendFilterloadMessage:[self bloomFilterForPeer:peer].data];
        [peer sendInvMessageWithTxHashes:self.publishedCallback.allKeys]; // publish pending tx
        [peer sendPingMessageWithPongHandler:^(BOOL success) {
            if (! success) return;
            [peer sendMempoolMessage:self.publishedTx.allKeys completion:^(BOOL success) {
                if (! success) return;
                peer.synced = YES;
                [self removeUnrelayedTransactions];
                [peer sendGetaddrMessage]; // request a list of other bitcoin peers
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification
                     object:nil];
                });
            }];
        }];

        return; // we're already connected to a download peer
    }

    // select the peer with the lowest ping time to download the chain from if we're behind
    // BUG: XXX a malicious peer can report a higher lastblock to make us select them as the download peer, if two
    // peers agree on lastblock, use one of them instead
    for (BRPeer *p in self.connectedPeers) {
        if (p.status != BRPeerStatusConnected) continue;
        if ((p.pingTime < peer.pingTime && p.lastblock >= peer.lastblock) || p.lastblock > peer.lastblock) peer = p;
    }

    [self.downloadPeer disconnect];
    self.downloadPeer = peer;
    _connected = YES;
    _estimatedBlockHeight = peer.lastblock;
    [peer sendFilterloadMessage:[self bloomFilterForPeer:peer].data];
    peer.currentBlockHeight = self.lastBlockHeight;
    
    if (self.lastBlockHeight < peer.lastblock) { // start blockchain sync
        self.lastRelayTime = 0;
        
        dispatch_async(dispatch_get_main_queue(), ^{ // setup a timer to detect if the sync stalls
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(syncTimeout) object:nil];
            [self performSelector:@selector(syncTimeout) withObject:nil afterDelay:PROTOCOL_TIMEOUT];

            dispatch_async(self.q, ^{
                // request just block headers up to a week before earliestKeyTime, and then merkleblocks after that
                // BUG: XXX headers can timeout on slow connections (each message is over 160k)
                if (self.lastBlock.timestamp + 7*24*60*60 >= self.earliestKeyTime + NSTimeIntervalSince1970) {
                    [peer sendGetblocksMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
                }
                else [peer sendGetheadersMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
            });
        });
    }
    else { // we're already synced
        self.syncStartHeight = 0;
        [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
        [self loadMempools];
    }
}

- (void)peer:(BRPeer *)peer disconnectedWithError:(NSError *)error
{
    NSLog(@"%@:%d disconnected%@%@", peer.host, peer.port, (error ? @", " : @""), (error ? error : @""));
    
    if ([error.domain isEqual:@"BreadWallet"] && error.code != BITCOIN_TIMEOUT_CODE) {
        [self peerMisbehavin:peer]; // if it's protocol error other than timeout, the peer isn't following the rules
    }
    else if (error) { // timeout or some non-protocol related network error
        [self.peers removeObject:peer];
        self.connectFailures++;
    }

    for (NSValue *txHash in self.txRelays.allKeys) {
        [self.txRelays[txHash] removeObject:peer];
    }

    if ([self.downloadPeer isEqual:peer]) { // download peer disconnected
        _connected = NO;
        self.downloadPeer = nil;
        if (self.connectFailures > MAX_CONNECT_FAILURES) self.connectFailures = MAX_CONNECT_FAILURES;
    }

    if (! self.connected && self.connectFailures == MAX_CONNECT_FAILURES) {
        [self syncStopped];
        
        // clear out stored peers so we get a fresh list from DNS on next connect attempt
        [self.misbehavinPeers removeAllObjects];
        [BRPeerEntity deleteObjects:[BRPeerEntity allObjects]];
        _peers = nil;

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerSyncFailedNotification
             object:nil userInfo:(error) ? @{@"error":error} : nil];
        });
    }
    else if (self.connectFailures < MAX_CONNECT_FAILURES && (self.taskId != UIBackgroundTaskInvalid ||
             [UIApplication sharedApplication].applicationState != UIApplicationStateBackground)) {
        [self connect]; // try connecting to another peer
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
    });
}

- (void)peer:(BRPeer *)peer relayedPeers:(NSArray *)peers
{
    NSLog(@"%@:%d relayed %d peer(s)", peer.host, peer.port, (int)peers.count);
    [self.peers addObjectsFromArray:peers];
    [self.peers minusSet:self.misbehavinPeers];
    [self sortPeers];

    // limit total to 2500 peers
    if (self.peers.count > 2500) [self.peers removeObjectsInRange:NSMakeRange(2500, self.peers.count - 2500)];

    NSTimeInterval now = [NSDate timeIntervalSinceReferenceDate];

    // remove peers more than 3 hours old, or until there are only 1000 left
    while (self.peers.count > 1000 && ((BRPeer *)self.peers.lastObject).timestamp + 3*60*60 < now) {
        [self.peers removeObject:self.peers.lastObject];
    }

    if (peers.count > 1 && peers.count < 1000) [self savePeers]; // peer relaying is complete when we receive <1000
}

- (void)peer:(BRPeer *)peer relayedTransaction:(BRTransaction *)transaction
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(transaction.txHash);
    BOOL syncing = (self.lastBlockHeight < self.estimatedBlockHeight);
    void (^callback)(NSError *error) = self.publishedCallback[hash];

    NSLog(@"%@:%d relayed transaction %@", peer.host, peer.port, hash);
    
    transaction.timestamp = [NSDate timeIntervalSinceReferenceDate];
    if (syncing && ! [manager.wallet containsTransaction:transaction]) return;
    if (! [manager.wallet registerTransaction:transaction]) return;
    if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];

    if ([manager.wallet amountSentByTransaction:transaction] > 0 && [manager.wallet transactionIsValid:transaction]) {
        [self addTransactionToPublishList:transaction]; // add valid send tx to mempool
    }
    
    // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
    if (callback || (! syncing && ! [self.txRelays[hash] containsObject:peer])) {
        if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
        [self.txRelays[hash] addObject:peer];
        if (callback) [self.publishedCallback removeObjectForKey:hash];

        if ([self.txRelays[hash] count] >= PEER_MAX_CONNECTIONS &&
            [manager.wallet transactionForHash:transaction.txHash].blockHeight == TX_UNCONFIRMED &&
            [manager.wallet transactionForHash:transaction.txHash].timestamp == 0) {
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:[NSDate timeIntervalSinceReferenceDate]
             forTxHashes:@[hash]]; // set timestamp when tx is verified
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            NSError *kvErr = nil;
            
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
            if (callback) callback(nil);
            
            [[BRAPIClient sharedClient].kv
             set:[[BRTxMetadataObject alloc] initWithTransaction:transaction exchangeRate:manager.localCurrencyPrice
                  exchangeRateCurrency:manager.localCurrencyCode feeRate:manager.wallet.feePerKb
                  deviceId:[BRAPIClient sharedClient].deviceId] error:&kvErr];
        });
    }
    
    [self.nonFpTx addObject:hash];
    [self.txRequests[hash] removeObject:peer];
    if (! _bloomFilter) return; // bloom filter is aready being updated

    // the transaction likely consumed one or more wallet addresses, so check that at least the next <gap limit>
    // unused addresses are still matched by the bloom filter
    NSArray *external = [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_EXTERNAL internal:NO],
            *internal = [manager.wallet addressesWithGapLimit:SEQUENCE_GAP_LIMIT_INTERNAL internal:YES];
    
    for (NSString *address in [external arrayByAddingObjectsFromArray:internal]) {
        NSData *hash = address.addressToHash160;

        if (! hash || [_bloomFilter containsData:hash]) continue;
        _bloomFilter = nil; // reset bloom filter so it's recreated with new wallet addresses
        [self updateFilter];
        break;
    }
}

- (void)peer:(BRPeer *)peer hasTransaction:(UInt256)txHash
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(txHash);
    BOOL syncing = (self.lastBlockHeight < self.estimatedBlockHeight);
    BRTransaction *tx = self.publishedTx[hash];
    void (^callback)(NSError *error) = self.publishedCallback[hash];
    
    NSLog(@"%@:%d has transaction %@", peer.host, peer.port, hash);
    if (! tx) tx = [manager.wallet transactionForHash:txHash];
    if (! tx || (syncing && ! [manager.wallet containsTransaction:tx])) return;
    if (! [manager.wallet registerTransaction:tx]) return;
    if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
    
    // keep track of how many peers have or relay a tx, this indicates how likely the tx is to confirm
    if (callback || (! syncing && ! [self.txRelays[hash] containsObject:peer])) {
        if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
        [self.txRelays[hash] addObject:peer];
        if (callback) [self.publishedCallback removeObjectForKey:hash];

        if ([self.txRelays[hash] count] >= PEER_MAX_CONNECTIONS &&
            [manager.wallet transactionForHash:txHash].blockHeight == TX_UNCONFIRMED &&
            [manager.wallet transactionForHash:txHash].timestamp == 0) {
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:[NSDate timeIntervalSinceReferenceDate]
             forTxHashes:@[hash]]; // set timestamp when tx is verified
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            NSError *kvErr = nil;
            
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
            if (callback) callback(nil);

            [[BRAPIClient sharedClient].kv
             set:[[BRTxMetadataObject alloc] initWithTransaction:tx exchangeRate:manager.localCurrencyPrice
                  exchangeRateCurrency:manager.localCurrencyCode feeRate:manager.wallet.feePerKb
                  deviceId:[BRAPIClient sharedClient].deviceId] error:&kvErr];
        });
    }
    
    [self.nonFpTx addObject:hash];
    [self.txRequests[hash] removeObject:peer];
}

- (void)peer:(BRPeer *)peer rejectedTransaction:(UInt256)txHash withCode:(uint8_t)code
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    BRTransaction *tx = [manager.wallet transactionForHash:txHash];
    NSValue *hash = uint256_obj(txHash);
    
    if ([self.txRelays[hash] containsObject:peer]) {
        [self.txRelays[hash] removeObject:peer];

        if (tx.blockHeight == TX_UNCONFIRMED) { // set timestamp 0 for unverified
            [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:@[hash]];
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
#if DEBUG
            [[[UIAlertView alloc] initWithTitle:@"transaction rejected"
              message:[NSString stringWithFormat:@"rejected by %@:%d with code 0x%x", peer.host, peer.port, code]
              delegate:nil cancelButtonTitle:@"ok" otherButtonTitles:nil] show];
#endif
        });
    }
    
    [self.txRequests[hash] removeObject:peer];
    
    // if we get rejected for any reason other than double-spend, the peer is likely misconfigured
    if (code != REJECT_SPENT && [manager.wallet amountSentByTransaction:tx] > 0) {
        for (hash in tx.inputHashes) { // check that all inputs are confirmed before dropping peer
            UInt256 h = UINT256_ZERO;
            
            [hash getValue:&h];
            if ([manager.wallet transactionForHash:h].blockHeight == TX_UNCONFIRMED) return;
        }

        [self peerMisbehavin:peer];
    }
}

- (void)peer:(BRPeer *)peer relayedBlock:(BRMerkleBlock *)block
{
    // ignore block headers that are newer than one week before earliestKeyTime (headers have 0 totalTransactions)
    if (block.totalTransactions == 0 &&
        block.timestamp + 7*24*60*60 > self.earliestKeyTime + NSTimeIntervalSince1970 + 2*60*60) return;

    NSArray *txHashes = block.txHashes;

    // track the observed bloom filter false positive rate using a low pass filter to smooth out variance
    if (peer == self.downloadPeer && block.totalTransactions > 0) {
        NSMutableSet *fp = [NSMutableSet setWithArray:txHashes];
    
        // 1% low pass filter, also weights each block by total transactions, using 1400 tx per block as typical
        [fp minusSet:self.nonFpTx]; // wallet tx are not false-positives
        [self.nonFpTx removeAllObjects];
        self.fpRate = self.fpRate*(1.0 - 0.01*block.totalTransactions/1400) + 0.01*fp.count/1400;

        // false positive rate sanity check
        if (self.downloadPeer.status == BRPeerStatusConnected && self.fpRate > BLOOM_DEFAULT_FALSEPOSITIVE_RATE*10.0) {
            NSLog(@"%@:%d bloom filter false positive rate %f too high after %d blocks, disconnecting...", peer.host,
                  peer.port, self.fpRate, self.lastBlockHeight + 1 - self.filterUpdateHeight);
            [self.downloadPeer disconnect];
        }
        else if (self.lastBlockHeight + 500 < peer.lastblock && self.fpRate > BLOOM_REDUCED_FALSEPOSITIVE_RATE*10.0) {
            [self updateFilter]; // rebuild bloom filter when it starts to degrade
        }
    }

    if (! _bloomFilter) { // ingore potentially incomplete blocks when a filter update is pending
        if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
        return;
    }

    NSValue *blockHash = uint256_obj(block.blockHash), *prevBlock = uint256_obj(block.prevBlock);
    BRMerkleBlock *prev = self.blocks[prevBlock];
    uint32_t transitionTime = 0, txTime = 0;
    UInt256 checkpoint = UINT256_ZERO;
    BOOL syncDone = NO;
    
    if (! prev) { // block is an orphan
        NSLog(@"%@:%d relayed orphan block %@, previous %@, last block is %@, height %d", peer.host, peer.port,
              blockHash, prevBlock, uint256_obj(self.lastBlock.blockHash), self.lastBlockHeight);

        // ignore orphans older than one week ago
        if (block.timestamp < [NSDate timeIntervalSinceReferenceDate] + NSTimeIntervalSince1970 - 7*24*60*60) return;

        // call getblocks, unless we already did with the previous block, or we're still downloading the chain
        if (self.lastBlockHeight >= peer.lastblock && ! uint256_eq(self.lastOrphan.blockHash, block.prevBlock)) {
            NSLog(@"%@:%d calling getblocks", peer.host, peer.port);
            [peer sendGetblocksMessageWithLocators:[self blockLocatorArray] andHashStop:UINT256_ZERO];
        }

        self.orphans[prevBlock] = block; // orphans are indexed by prevBlock instead of blockHash
        self.lastOrphan = block;
        return;
    }

    block.height = prev.height + 1;
    txTime = block.timestamp/2 + prev.timestamp/2;

    if ((block.height % nInterval) == 0) { // hit a difficulty transition, find previous transition time
        BRMerkleBlock *b = block;

        for (uint32_t i = 0; b && i < nInterval; i++) {
            b = self.blocks[uint256_obj(b.prevBlock)];
        }

        [[BRMerkleBlockEntity context] performBlock:^{ // save transition blocks to core data immediately
            @autoreleasepool {
                BRMerkleBlockEntity *e = [BRMerkleBlockEntity objectsMatching:@"blockHash == %@",
                                          [NSData dataWithBytes:b.blockHash.u8 length:sizeof(UInt256)]].lastObject;
        
                if (! e) e = [BRMerkleBlockEntity managedObject];
                [e setAttributesFromBlock:b];
            }
            
            [BRMerkleBlockEntity saveContext]; // persist core data to disk
        }];

        transitionTime = b.timestamp;
        
        while (b) { // free up some memory
            b = self.blocks[uint256_obj(b.prevBlock)];

            if (b && (b.height % nInterval) != 0) {
                [self.blocks removeObjectForKey:uint256_obj(b.blockHash)];
            }
        }
    }

    // verify block difficulty
    if (! [block verifyDifficultyFromPreviousBlock:prev andTransitionTime:transitionTime]) {
        NSLog(@"%@:%d relayed block with invalid difficulty target %x, blockHash: %@", peer.host, peer.port,
              block.target, blockHash);
        [self peerMisbehavin:peer];
        return;
    }

    [self.checkpoints[@(block.height)] getValue:&checkpoint];
    
    // verify block chain checkpoints
    if (! uint256_is_zero(checkpoint) && ! uint256_eq(block.blockHash, checkpoint)) {
        NSLog(@"%@:%d relayed a block that differs from the checkpoint at height %d, blockHash: %@, expected: %@",
              peer.host, peer.port, block.height, blockHash, self.checkpoints[@(block.height)]);
        [self peerMisbehavin:peer];
        return;
    }
    
    if (uint256_eq(block.prevBlock, self.lastBlock.blockHash)) { // new block extends main chain
        if ((block.height % 500) == 0 || txHashes.count > 0 || block.height > peer.lastblock) {
            NSLog(@"adding block at height: %d, false positive rate: %f", block.height, self.fpRate);
        }

        self.blocks[blockHash] = block;
        self.lastBlock = block;
        [self setBlockHeight:block.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:txHashes];
        if (peer == self.downloadPeer) self.lastRelayTime = [NSDate timeIntervalSinceReferenceDate];
        self.downloadPeer.currentBlockHeight = block.height;
        if (block.height == _estimatedBlockHeight) syncDone = YES;
    }
    else if (self.blocks[blockHash] != nil) { // we already have the block (or at least the header)
        if ((block.height % 500) == 0 || txHashes.count > 0 || block.height > peer.lastblock) {
            NSLog(@"%@:%d relayed existing block at height %d", peer.host, peer.port, block.height);
        }

        self.blocks[blockHash] = block;

        BRMerkleBlock *b = self.lastBlock;

        while (b && b.height > block.height) b = self.blocks[uint256_obj(b.prevBlock)]; // is block in main chain?

        if (uint256_eq(b.blockHash, block.blockHash)) { // if it's not on a fork, set block heights for its transactions
            [self setBlockHeight:block.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:txHashes];
            if (block.height == self.lastBlockHeight) self.lastBlock = block;
        }
    }
    else { // new block is on a fork
        if (block.height <= checkpoint_array[CHECKPOINT_COUNT - 1].height) { // fork is older than last checkpoint
            NSLog(@"ignoring block on fork older than most recent checkpoint, fork height: %d, blockHash: %@",
                  block.height, blockHash);
            return;
        }

        // special case, if a new block is mined while we're rescanning the chain, mark as orphan til we're caught up
        if (self.lastBlockHeight < peer.lastblock && block.height > self.lastBlockHeight + 1) {
            NSLog(@"marking new block at height %d as orphan until rescan completes", block.height);
            self.orphans[prevBlock] = block;
            self.lastOrphan = block;
            return;
        }

        NSLog(@"chain fork to height %d", block.height);
        self.blocks[blockHash] = block;
        if (block.height <= self.lastBlockHeight) return; // if fork is shorter than main chain, ignore it for now

        NSMutableArray *txHashes = [NSMutableArray array];
        BRMerkleBlock *b = block, *b2 = self.lastBlock;

        while (b && b2 && ! uint256_eq(b.blockHash, b2.blockHash)) { // walk back to where the fork joins the main chain
            b = self.blocks[uint256_obj(b.prevBlock)];
            if (b.height < b2.height) b2 = self.blocks[uint256_obj(b2.prevBlock)];
        }

        NSLog(@"reorganizing chain from height %d, new height is %d", b.height, block.height);

        // mark transactions after the join point as unconfirmed
        for (BRTransaction *tx in [BRWalletManager sharedInstance].wallet.allTransactions) {
            if (tx.blockHeight <= b.height) break;
            [txHashes addObject:uint256_obj(tx.txHash)];
        }

        [self setBlockHeight:TX_UNCONFIRMED andTimestamp:0 forTxHashes:txHashes];
        b = block;

        while (b.height > b2.height) { // set transaction heights for new main chain
            [self setBlockHeight:b.height andTimestamp:txTime - NSTimeIntervalSince1970 forTxHashes:b.txHashes];
            b = self.blocks[uint256_obj(b.prevBlock)];
            txTime = b.timestamp/2 + ((BRMerkleBlock *)self.blocks[uint256_obj(b.prevBlock)]).timestamp/2;
        }

        self.lastBlock = block;
        if (block.height == _estimatedBlockHeight) syncDone = YES;
    }

    if (syncDone) { // chain download is complete
        self.syncStartHeight = 0;
        [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:SYNC_STARTHEIGHT_KEY];
        [self saveBlocks];
        [self loadMempools];
    }
    
    if (block.height > _estimatedBlockHeight) {
        _estimatedBlockHeight = block.height;
    
        // notify that transaction confirmations may have changed
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:BRPeerManagerTxStatusNotification object:nil];
        });
    }
    
    // check if the next block was received as an orphan
    if (block == self.lastBlock && self.orphans[blockHash]) {
        BRMerkleBlock *b = self.orphans[blockHash];
        
        [self.orphans removeObjectForKey:blockHash];
        [self peer:peer relayedBlock:b];
    }
}

- (void)peer:(BRPeer *)peer notfoundTxHashes:(NSArray *)txHashes andBlockHashes:(NSArray *)blockhashes
{
    for (NSValue *hash in txHashes) {
        [self.txRelays[hash] removeObject:peer];
        [self.txRequests[hash] removeObject:peer];
    }
}

- (void)peer:(BRPeer *)peer setFeePerKb:(uint64_t)feePerKb
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    uint64_t maxFeePerKb = 0, secondFeePerKb = 0;
    
    for (BRPeer *p in self.connectedPeers) { // find second highest fee rate
        if (p.status != BRPeerStatusConnected) continue;
        if (p.feePerKb > maxFeePerKb) secondFeePerKb = maxFeePerKb, maxFeePerKb = p.feePerKb;
    }
    
    if (secondFeePerKb*2 > MIN_FEE_PER_KB && secondFeePerKb*2 <= MAX_FEE_PER_KB &&
        secondFeePerKb*2 > manager.wallet.feePerKb) {
        NSLog(@"increasing feePerKb to %llu based on feefilter messages from peers", secondFeePerKb*2);
        manager.wallet.feePerKb = secondFeePerKb*2;
    }
}

- (BRTransaction *)peer:(BRPeer *)peer requestedTransaction:(UInt256)txHash
{
    BRWalletManager *manager = [BRWalletManager sharedInstance];
    NSValue *hash = uint256_obj(txHash);
    BRTransaction *tx = self.publishedTx[hash];
    void (^callback)(NSError *error) = self.publishedCallback[hash];
    NSError *error = nil;

    if (! self.txRelays[hash]) self.txRelays[hash] = [NSMutableSet set];
    [self.txRelays[hash] addObject:peer];
    [self.nonFpTx addObject:hash];
    [self.publishedCallback removeObjectForKey:hash];
    
    if (callback && ! [manager.wallet transactionIsValid:tx]) {
        [self.publishedTx removeObjectForKey:hash];
        error = [NSError errorWithDomain:@"BreadWallet" code:401
                 userInfo:@{NSLocalizedDescriptionKey:NSLocalizedString(@"double spend", nil)}];
    }
    else if (tx && ! [manager.wallet transactionForHash:txHash] && [manager.wallet registerTransaction:tx]) {
        [[BRTransactionEntity context] performBlock:^{
            [BRTransactionEntity saveContext]; // persist transactions to core data
        }];
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(txTimeout:) object:hash];
        if (callback) callback(error);
    });

//    [peer sendPingMessageWithPongHandler:^(BOOL success) { // check if peer will relay the transaction back
//        if (! success) return;
//        
//        if (! [self.txRequests[hash] containsObject:peer]) {
//            if (! self.txRequests[hash]) self.txRequests[hash] = [NSMutableSet set];
//            [self.txRequests[hash] addObject:peer];
//            [peer sendGetdataMessageWithTxHashes:@[hash] andBlockHashes:nil];
//        }
//    }];

    return tx;
}

// MARK: - UIAlertViewDelegate

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == alertView.cancelButtonIndex) return;
    [self rescan];
}

@end
